[["index.html", "R Note Intro to R", " R Note Seungwon Song Update - 2021-07-15 Intro to R R is one of the best language for statistics. Sometimes it is compared with python. Python is nice tool for data analysis, especially machine learning or deep learning. But being able to handle R will gives anyone who works with data and statistics another huge advantage. This note will not cover too detailed grammar, internal principles, or advanced techniques. However, it focuses on how to handle data through R even if you do not know R syntax. Then, let’s start lightly! "],["r-basic.html", "Chapter 1 R Basic 1.1 Data Types I 1.2 Data Types - character 1.3 Data Types - numeric, integer, complex 1.4 Data Types - logical 1.5 Data Types II 1.6 Data Types - raw 1.7 Data Types - factor 1.8 Data Types - ordered factor 1.9 Data Types - date 1.10 Data Structure 1.11 Data Structure - vector 1.12 Data Structure - matrix 1.13 Data Structure - dataframe 1.14 Data Structure - array 1.15 Data Structure - list", " Chapter 1 R Basic Let’s check the types and data structures in R. At the same time, let’s prepare to deal with R by taking a look at the built-in functions that R has by default. 1.1 Data Types I R has 5 basic data types. character numeric integer complex logical 1.2 Data Types - character And we can deal with these data types by using basic functions. character(3) # show the collection of 3 character elements ## [1] &quot;&quot; &quot;&quot; &quot;&quot; typeof(&#39;Hello&#39;) # show the type of &#39;Hello&#39;(character) ## [1] &quot;character&quot; length(&#39;Hello&#39;) # show the length of &#39;Hello&#39;(1 character) ## [1] 1 str(&#39;Hello&#39;) # show the structure of &#39;Hello&#39; ## chr &quot;Hello&quot; 1.3 Data Types - numeric, integer, complex There are 3 ways to represent numbers numeric(3) ## [1] 0 0 0 integer(3) ## [1] 0 0 0 complex(3) ## [1] 0+0i 0+0i 0+0i typeof(numeric(3)) ## [1] &quot;double&quot; typeof(integer(3)) ## [1] &quot;integer&quot; typeof(complex(3)) ## [1] &quot;complex&quot; str(numeric(3)) ## num [1:3] 0 0 0 str(integer(3)) ## int [1:3] 0 0 0 str(complex(3)) ## cplx [1:3] 0+0i 0+0i 0+0i 1.4 Data Types - logical and logical type. logical(5) # show the collection of 5 logical elements ## [1] FALSE FALSE FALSE FALSE FALSE typeof(logical(5)) # show the type of the logical collection ## [1] &quot;logical&quot; length(logical(5)) # show the length of the logical collection, or the number of the logical elements(5) ## [1] 5 str(logical(5)) # show the structure of the logical collection ## logi [1:5] FALSE FALSE FALSE FALSE FALSE 1.5 Data Types II Here are some other useful data types. raw factor Date 1.6 Data Types - raw The raw can represent a hex digit. So if we want to get ASCII code, we can use this. Contrary, we can convert ASCII code to ASCII characters. raw(5) ## [1] 00 00 00 00 00 typeof(raw(5)) ## [1] &quot;raw&quot; length(raw(5)) ## [1] 5 ctr &lt;- charToRaw(&#39;hi this is ASCII&#39;) print(ctr) ## [1] 68 69 20 74 68 69 73 20 69 73 20 41 53 43 49 49 rawToChar(ctr) ## [1] &quot;hi this is ASCII&quot; 1.7 Data Types - factor In statistics, variables are divided into categorical variables (discrete variables) and continuous variables. Going deeper, categorical variables can be divided into “normal variables with no order between variables” and “ordinal variables with order between variables,” and continuous variables are “interval variables without absolute zeros” and “Ratio variables with absolute zeros” can be divided into. Categorical variable norminal variable ordinal variable Continuous variable interval variable ratio variable In this classification, Categorical variables can be represented as factor type in R. The factor type can be used with factor() and ordered(). In particular, when data is composed of numbers, it is important to understand whether this has meaning in order, and factor() excludes meaning in order by expressing it as a category. c(1,2,3,1,2,3,4) ## [1] 1 2 3 1 2 3 4 factor(c(1,2,3,1,2,3,4)) ## [1] 1 2 3 1 2 3 4 ## Levels: 1 2 3 4 1.8 Data Types - ordered factor Also, an order can be added to the factor form. If you use factor(), you can create a norminal variable, and if you use ordered(), you can create an ordinal variable. ordered(c(1,2,3,1,2,3,1,2)) ## [1] 1 2 3 1 2 3 1 2 ## Levels: 1 &lt; 2 &lt; 3 ordered() is especially effective when working with categorical data that has an ordered literal representation. ordered(c(&#39;Short&#39;,&#39;Tall&#39;,&#39;Grande&#39;,&#39;Tall&#39;,&#39;Short&#39;,&#39;Tall&#39;), levels=c(&#39;Short&#39;,&#39;Tall&#39;,&#39;Grande&#39;)) ## [1] Short Tall Grande Tall Short Tall ## Levels: Short &lt; Tall &lt; Grande Of course, it is also possible to change the levels in descending order or add a level that is not in the current data in advance. ordered(c(1,2,3,1,2,1,2,3,1), levels=c(4,3,2,1)) ## [1] 1 2 3 1 2 1 2 3 1 ## Levels: 4 &lt; 3 &lt; 2 &lt; 1 1.9 Data Types - date We’ll deal with the date type from now on, but we’ll use the method that converts a specific string to a date because we can put it in a function as a string or a number. day_info &lt;- c(&#39;2018-12-24&#39;,&#39;2018-12-25&#39;) day_info ## [1] &quot;2018-12-24&quot; &quot;2018-12-25&quot; typeof(day_info) ## [1] &quot;character&quot; date_info &lt;- as.Date(day_info) date_info ## [1] &quot;2018-12-24&quot; &quot;2018-12-25&quot; typeof(date_info) ## [1] &quot;double&quot; The results don’t look much different. Why do we need this type? The reason we use date type is usually for time series analysis. This enables time calculation. date_info[2] - date_info[1] ## Time difference of 1 days If we had subtracted from day_info, we would have had an error. 1.10 Data Structure Data structure is container that contain data elements. There are 5 basic data structures in R. vector matrix dataframe array list 1.11 Data Structure - vector A vector is a data structure composed of one or more elements, and all elements must have the same data type. In fact, we made and output a vector while checking each type earlier. sample &lt;- &#39;A&#39; sample2 &lt;- c(1,2) sample3 &lt;- c(1,2,&#39;A&#39;) str(sample) ## chr &quot;A&quot; str(sample2) ## num [1:2] 1 2 str(sample3) ## chr [1:3] &quot;1&quot; &quot;2&quot; &quot;A&quot; All of that are vectors. The peculiar thing is that sample3 is of type chr. Repeat, all elements must have the same data type in vector. We see here that classes are not represented as vectors in vector structures. In R, a vector is the smallest data structure unit, so the class of the vector is data type as it is. 1.12 Data Structure - matrix Matrix is 2 dimension data structure and it requires all elements in this structure to be of the same data type. vector1 &lt;- c(1,2,3,4,5,6,7,8,9,10) Create a metric by filling the column first : matrix(vector1, nrow=2, ncol=5) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 Create a metric by filling the row first : matrix(vector1, nrow=2, ncol=5, byrow=T) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 6 7 8 9 10 Check the type of data(metrix) : mtr &lt;- matrix(vector1, nrow=2, ncol=5, byrow=T) class(mtr) ## [1] &quot;matrix&quot; &quot;array&quot; Unlike vectors, matrix represent classes well as “matrix.” If, you want to combine multiple vectors, you can use cbind or rbind. vector2 &lt;- c(10,20,30,40,50,60,70,80,90,100) cbind(vector1, vector2) ## vector1 vector2 ## [1,] 1 10 ## [2,] 2 20 ## [3,] 3 30 ## [4,] 4 40 ## [5,] 5 50 ## [6,] 6 60 ## [7,] 7 70 ## [8,] 8 80 ## [9,] 9 90 ## [10,] 10 100 If cbind combines vectors on a column basis, rbind can combine on a row basis. rbind(vector1[1:5], vector2[1:5]) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 10 20 30 40 50 We used indexing here. Only a specific section of a vector can be extracted through ‘[a,b].’ Let’s take a quick look at indexing. vector2[c(1,3,5,7)] ## [1] 10 30 50 70 vector2[seq(1,8,2)] ## [1] 10 30 50 70 vector2[-1] ## [1] 20 30 40 50 60 70 80 90 100 In this way, you can extract a value with a specific index through c(), set the interval and search interval with seq(), or exclude only the value of a specific index.(-) Next, Matrix indexing. mtr ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 6 7 8 9 10 row - 1, column - 1~3 : mtr[1,1:3] ## [1] 1 2 3 row - all, column - 4~5 : mtr[,4:5] ## [,1] [,2] ## [1,] 4 5 ## [2,] 9 10 row - 2, column - all : mtr[2,] ## [1] 6 7 8 9 10 row - all, column - 1,3,5 : mtr[,c(1,3,5)] ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 6 8 10 row - all, column - extract 1 and all : mtr[,-1] ## [,1] [,2] [,3] [,4] ## [1,] 2 3 4 5 ## [2,] 7 8 9 10 Indexing is very important. Handling vectors and matrices freely is a key skill that must be preceded by data preprocessing. 1.13 Data Structure - dataframe Dataframe is 2 dimension data structure that it’s datatypes do not need to be uniform. That is, unlike a matrix, various types of vectors can be combined. column1 &lt;- c(1,2,3,4,5) column2 &lt;- c(10,20,30,40,50) column3 &lt;- c(&#39;hi&#39;, &#39;this&#39;, &#39;is&#39;, &#39;vector&#39;, &#39;!&#39;) sample_df &lt;- data.frame(column1, column2, column3) str(sample_df) ## &#39;data.frame&#39;: 5 obs. of 3 variables: ## $ column1: num 1 2 3 4 5 ## $ column2: num 10 20 30 40 50 ## $ column3: chr &quot;hi&quot; &quot;this&quot; &quot;is&quot; &quot;vector&quot; ... class(sample_df) ## [1] &quot;data.frame&quot; The indexing used for metrics can be applied to data frames as well. sample_df ## column1 column2 column3 ## 1 1 10 hi ## 2 2 20 this ## 3 3 30 is ## 4 4 40 vector ## 5 5 50 ! row - 1, column - all : sample_df[1, ] ## column1 column2 column3 ## 1 1 10 hi row - all, column - 1~2 : sample_df[,1:2] ## column1 column2 ## 1 1 10 ## 2 2 20 ## 3 3 30 ## 4 4 40 ## 5 5 50 row - all, column - extract 1 and all : sample_df[,-1] ## column2 column3 ## 1 10 hi ## 2 20 this ## 3 30 is ## 4 40 vector ## 5 50 ! 1.14 Data Structure - array An array is a multi-dimensional data structure that can express two or more dimensions of a matrix, and all elements must be of the same data type, just like a matrix. 1 dimension : array(1:10) ## [1] 1 2 3 4 5 6 7 8 9 10 2 dimension : array(1:10, dim=c(5,2)) # c(row, column) ## [,1] [,2] ## [1,] 1 6 ## [2,] 2 7 ## [3,] 3 8 ## [4,] 4 9 ## [5,] 5 10 3 dimension : array(1:30, dim=c(5,2,3)) # c(row, column, N) ## , , 1 ## ## [,1] [,2] ## [1,] 1 6 ## [2,] 2 7 ## [3,] 3 8 ## [4,] 4 9 ## [5,] 5 10 ## ## , , 2 ## ## [,1] [,2] ## [1,] 11 16 ## [2,] 12 17 ## [3,] 13 18 ## [4,] 14 19 ## [5,] 15 20 ## ## , , 3 ## ## [,1] [,2] ## [1,] 21 26 ## [2,] 22 27 ## [3,] 23 28 ## [4,] 24 29 ## [5,] 25 30 4 dimension : array(1:200, dim=c(5, 10, 2, 2)) # c(row, column, N, N) ## , , 1, 1 ## ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## [1,] 1 6 11 16 21 26 31 36 41 46 ## [2,] 2 7 12 17 22 27 32 37 42 47 ## [3,] 3 8 13 18 23 28 33 38 43 48 ## [4,] 4 9 14 19 24 29 34 39 44 49 ## [5,] 5 10 15 20 25 30 35 40 45 50 ## ## , , 2, 1 ## ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## [1,] 51 56 61 66 71 76 81 86 91 96 ## [2,] 52 57 62 67 72 77 82 87 92 97 ## [3,] 53 58 63 68 73 78 83 88 93 98 ## [4,] 54 59 64 69 74 79 84 89 94 99 ## [5,] 55 60 65 70 75 80 85 90 95 100 ## ## , , 1, 2 ## ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## [1,] 101 106 111 116 121 126 131 136 141 146 ## [2,] 102 107 112 117 122 127 132 137 142 147 ## [3,] 103 108 113 118 123 128 133 138 143 148 ## [4,] 104 109 114 119 124 129 134 139 144 149 ## [5,] 105 110 115 120 125 130 135 140 145 150 ## ## , , 2, 2 ## ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## [1,] 151 156 161 166 171 176 181 186 191 196 ## [2,] 152 157 162 167 172 177 182 187 192 197 ## [3,] 153 158 163 168 173 178 183 188 193 198 ## [4,] 154 159 164 169 174 179 184 189 194 199 ## [5,] 155 160 165 170 175 180 185 190 195 200 We can use indexing for array too. But it could be more complex than matrix or vector. test &lt;- array(1:200, dim=c(5, 10, 2, 2)) test[3:5,,,] # row indexing ## , , 1, 1 ## ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## [1,] 3 8 13 18 23 28 33 38 43 48 ## [2,] 4 9 14 19 24 29 34 39 44 49 ## [3,] 5 10 15 20 25 30 35 40 45 50 ## ## , , 2, 1 ## ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## [1,] 53 58 63 68 73 78 83 88 93 98 ## [2,] 54 59 64 69 74 79 84 89 94 99 ## [3,] 55 60 65 70 75 80 85 90 95 100 ## ## , , 1, 2 ## ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## [1,] 103 108 113 118 123 128 133 138 143 148 ## [2,] 104 109 114 119 124 129 134 139 144 149 ## [3,] 105 110 115 120 125 130 135 140 145 150 ## ## , , 2, 2 ## ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## [1,] 153 158 163 168 173 178 183 188 193 198 ## [2,] 154 159 164 169 174 179 184 189 194 199 ## [3,] 155 160 165 170 175 180 185 190 195 200 test[3:5,5:8,,] # row and column indexing ## , , 1, 1 ## ## [,1] [,2] [,3] [,4] ## [1,] 23 28 33 38 ## [2,] 24 29 34 39 ## [3,] 25 30 35 40 ## ## , , 2, 1 ## ## [,1] [,2] [,3] [,4] ## [1,] 73 78 83 88 ## [2,] 74 79 84 89 ## [3,] 75 80 85 90 ## ## , , 1, 2 ## ## [,1] [,2] [,3] [,4] ## [1,] 123 128 133 138 ## [2,] 124 129 134 139 ## [3,] 125 130 135 140 ## ## , , 2, 2 ## ## [,1] [,2] [,3] [,4] ## [1,] 173 178 183 188 ## [2,] 174 179 184 189 ## [3,] 175 180 185 190 test[3:5,5:8,2,2] # row and column + N(2,2) indexing ==&gt; extract part(some rows and some columns) of last matrix in array ## [,1] [,2] [,3] [,4] ## [1,] 173 178 183 188 ## [2,] 174 179 184 189 ## [3,] 175 180 185 190 1.15 Data Structure - list List is the most flexible data structure in R. It can be expressed in all dimensions and can be expressed by collecting various data types. li &lt;- list(c(1,2,3,4), c(&#39;hi&#39;,&#39;im&#39;,&#39;in&#39;,&#39;list&#39;), sample_df) li ## [[1]] ## [1] 1 2 3 4 ## ## [[2]] ## [1] &quot;hi&quot; &quot;im&quot; &quot;in&quot; &quot;list&quot; ## ## [[3]] ## column1 column2 column3 ## 1 1 10 hi ## 2 2 20 this ## 3 3 30 is ## 4 4 40 vector ## 5 5 50 ! We can find double square brackets for each indexes. So if we want to extract some values(not vector) from list, we have to use double bracket(‘[[’, ’]]’). First, If we need to 1 vector in list, the indexing method above can be used. for example, sample_df[1] # extract 1 column(vector) ## column1 ## 1 1 ## 2 2 ## 3 3 ## 4 4 ## 5 5 li[1] ## [[1]] ## [1] 1 2 3 4 Here comes the other part, if you want to go deeper, i.e. extract only a few elements in smaller units, you have to use double brackets. Like this, li[[1]][1:3] ## [1] 1 2 3 What makes difference? In list, if we use one bracket, it returns list type. li[2] ## [[1]] ## [1] &quot;hi&quot; &quot;im&quot; &quot;in&quot; &quot;list&quot; typeof(li[2]) ## [1] &quot;list&quot; and if we use double brackets, it returns the collection’s data type. typeof(li[[2]]) ## [1] &quot;character&quot; That is why you need to use double brackets to access a specific value of a list in a list li[[2]][2:4] ## [1] &quot;im&quot; &quot;in&quot; &quot;list&quot; li[[3]][2:1,2:3] # indexing : first list, second dataframe ## column2 column3 ## 2 20 this ## 1 10 hi In the list, you can name the internal list just like the columns of the data frame. li2 &lt;- list(nu=c(1,2,3,4,5), ch=c(&#39;hi&#39;,&#39;hello&#39;,&#39;hey&#39;), df=data.frame(c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;),c(&#39;any&#39;,&#39;baby&#39;,&#39;can&#39;),c(10,11,12))) str(li2) ## List of 3 ## $ nu: num [1:5] 1 2 3 4 5 ## $ ch: chr [1:3] &quot;hi&quot; &quot;hello&quot; &quot;hey&quot; ## $ df:&#39;data.frame&#39;: 3 obs. of 3 variables: ## ..$ c..a....b....c.. : chr [1:3] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## ..$ c..any....baby....can..: chr [1:3] &quot;any&quot; &quot;baby&quot; &quot;can&quot; ## ..$ c.10..11..12. : num [1:3] 10 11 12 And if you’ve name each lists, you can call them using ‘$.’ li2$nu ## [1] 1 2 3 4 5 li2$ch ## [1] &quot;hi&quot; &quot;hello&quot; &quot;hey&quot; li2$df ## c..a....b....c.. c..any....baby....can.. c.10..11..12. ## 1 a any 10 ## 2 b baby 11 ## 3 c can 12 As you may have noticed, it does the same thing as double brackets. str(li2[[3]]) ## &#39;data.frame&#39;: 3 obs. of 3 variables: ## $ c..a....b....c.. : chr &quot;a&quot; &quot;b&quot; &quot;c&quot; ## $ c..any....baby....can..: chr &quot;any&quot; &quot;baby&quot; &quot;can&quot; ## $ c.10..11..12. : num 10 11 12 str(li2$df) ## &#39;data.frame&#39;: 3 obs. of 3 variables: ## $ c..a....b....c.. : chr &quot;a&quot; &quot;b&quot; &quot;c&quot; ## $ c..any....baby....can..: chr &quot;any&quot; &quot;baby&quot; &quot;can&quot; ## $ c.10..11..12. : num 10 11 12 Finally, let’s look at the difference between using only one bracket. str(li2[3]) ## List of 1 ## $ df:&#39;data.frame&#39;: 3 obs. of 3 variables: ## ..$ c..a....b....c.. : chr [1:3] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## ..$ c..any....baby....can..: chr [1:3] &quot;any&quot; &quot;baby&quot; &quot;can&quot; ## ..$ c.10..11..12. : num [1:3] 10 11 12 "],["exploratory-data-analysis.html", "Chapter 2 Exploratory Data Analysis 2.1 head and tail 2.2 dim and str 2.3 summary 2.4 table 2.5 qplot 2.6 hist 2.7 is.na 2.8 na.omit 2.9 barplot 2.10 boxplot 2.11 ggplot2 :: ggplot", " Chapter 2 Exploratory Data Analysis EDA(Exploratory Data Analysis) is necessary for data analyst to check the dataset before statistical modeling(or machine learning) 2.1 head and tail df_mpg &lt;- data.frame(ggplot2::mpg) head(df_mpg) ## manufacturer model displ year cyl trans drv cty hwy fl class ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compact ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compact ## 3 audi a4 2.0 2008 4 manual(m6) f 20 31 p compact ## 4 audi a4 2.0 2008 4 auto(av) f 21 30 p compact ## 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compact ## 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compact we have loaded mpg dataset from ggplot2 package. ggplot2 contains multiple useful datasets and various visualization tools. head function extract top 6 rows of input dataset. In contrast, we can extract bottom 6 rows using tail function. tail(df_mpg) ## manufacturer model displ year cyl trans drv cty hwy fl class ## 229 volkswagen passat 1.8 1999 4 auto(l5) f 18 29 p midsize ## 230 volkswagen passat 2.0 2008 4 auto(s6) f 19 28 p midsize ## 231 volkswagen passat 2.0 2008 4 manual(m6) f 21 29 p midsize ## 232 volkswagen passat 2.8 1999 6 auto(l5) f 16 26 p midsize ## 233 volkswagen passat 2.8 1999 6 manual(m5) f 18 26 p midsize ## 234 volkswagen passat 3.6 2008 6 auto(s6) f 17 26 p midsize It’s important to check rows in this way, because most of dataset we meet are so large that it can’t be shown just in one page. 2.2 dim and str using dim function, we can check the size of dataset. The size means rows x columns. dim(df_mpg) ## [1] 234 11 This mpg dataset has 234 rows and 11 columns(features). We do not need to use this function just for check entire dataset. dim(head(df_mpg)) ## [1] 6 11 dim(df_mpg[,2:4]) ## [1] 234 3 dim(df_mpg[&#39;model&#39;]) ## [1] 234 1 but we can’t use dim for 1-dim vector. Note that df_mpg[‘model’] is not a vector, it’s dataframe yet. str(df_mpg[&#39;model&#39;]) ## &#39;data.frame&#39;: 234 obs. of 1 variable: ## $ model: chr &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; ... It’s different from df_mpg$model str(df_mpg$model) ## chr [1:234] &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4 quattro&quot; &quot;a4 quattro&quot; ... This is vector. And it’s same with df_mpg[[‘model’]] str(df_mpg[[&#39;model&#39;]]) ## chr [1:234] &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4 quattro&quot; &quot;a4 quattro&quot; ... 2.3 summary we can check summary statistics using summary function. summary(df_mpg) ## manufacturer model displ year ## Length:234 Length:234 Min. :1.600 Min. :1999 ## Class :character Class :character 1st Qu.:2.400 1st Qu.:1999 ## Mode :character Mode :character Median :3.300 Median :2004 ## Mean :3.472 Mean :2004 ## 3rd Qu.:4.600 3rd Qu.:2008 ## Max. :7.000 Max. :2008 ## cyl trans drv cty ## Min. :4.000 Length:234 Length:234 Min. : 9.00 ## 1st Qu.:4.000 Class :character Class :character 1st Qu.:14.00 ## Median :6.000 Mode :character Mode :character Median :17.00 ## Mean :5.889 Mean :16.86 ## 3rd Qu.:8.000 3rd Qu.:19.00 ## Max. :8.000 Max. :35.00 ## hwy fl class ## Min. :12.00 Length:234 Length:234 ## 1st Qu.:18.00 Class :character Class :character ## Median :24.00 Mode :character Mode :character ## Mean :23.44 ## 3rd Qu.:27.00 ## Max. :44.00 If column is categorical variable, like model, trans, drv, manufacturer, fl, class, it just shows Length, Class and Mode. But in case of numerical, it can shows mean of variable, median of variable, minimum of variable, maximum of variable and 1st and 3rd quartile. 2.4 table And R also provides a frequency table. We can use this as call table function. table(df_mpg$model) ## ## 4runner 4wd a4 a4 quattro ## 6 7 8 ## a6 quattro altima c1500 suburban 2wd ## 3 6 5 ## camry camry solara caravan 2wd ## 7 7 11 ## civic corolla corvette ## 9 5 5 ## dakota pickup 4wd durango 4wd expedition 2wd ## 9 7 3 ## explorer 4wd f150 pickup 4wd forester awd ## 6 7 6 ## grand cherokee 4wd grand prix gti ## 8 5 5 ## impreza awd jetta k1500 tahoe 4wd ## 8 9 4 ## land cruiser wagon 4wd malibu maxima ## 2 5 3 ## mountaineer 4wd mustang navigator 2wd ## 4 9 3 ## new beetle passat pathfinder 4wd ## 6 7 4 ## ram 1500 pickup 4wd range rover sonata ## 10 4 7 ## tiburon toyota tacoma 4wd ## 7 7 table(df_mpg$class) ## ## 2seater compact midsize minivan pickup subcompact suv ## 5 47 41 11 33 35 62 It’s helpful to check counts of each values in variable. To better use, we can use this table with visualizing original variable. first, let’s import ggplot2 library library(ggplot2) qplot(df_mpg$class) You should be careful to visualize the table as it is. If you visualize the table, it shows the different one. qplot(table(df_mpg$class)) ## Don&#39;t know how to automatically pick scale for object of type table. Defaulting to continuous. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 2.5 qplot Visualization is always important part for EDA. Let’s study more about qplot. we use mpg dataset. Extract top 5 rows head(mpg) ## # A tibble: 6 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa… ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa… ## 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa… ## 4 audi a4 2 2008 4 auto(av) f 21 30 p compa… ## 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compa… ## 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compa… qplot means “quick plot.” It is useful for quickly running our plot. let’s see some feature’s frequency using qplot qplot(data=mpg, x=manufacturer) qplot(data=mpg, x=fl) qplot(data=mpg, x=year) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. it’s weired. year data have only 2 cases. let’s check that. table(mpg$year) ## ## 1999 2008 ## 117 117 yes. it’s contain only the car data that manufacturered in 1999 and 2008. We have to think about this when analysis this dataset. and let’s go ahead and check the other feature one more. qplot(data=mpg, x=class) like this, we can show data’s frequency by input x(feature). and class contains types of car like size or shape etc. table(mpg$class) ## ## 2seater compact midsize minivan pickup subcompact suv ## 5 47 41 11 33 35 62 Then, what will happen if we input y into qplot function? qplot(data=mpg, x=class, y=hwy) This is scatter plot. From this plot, we can check highway fuel economy of each car class. Pick-up truck and SUV are not good at average fuel economy. But, we have more useful plot than scatter plot for checking the mean of data. Let’s use that. qplot(data=mpg, x=class, y=hwy, geom=&#39;boxplot&#39;, color=class) It’s box plot. We can check means easily and even outliers. It’s very important that how our data visualized and what tools we use. If we use line plot for this situation, It is difficult to accurately show the data. qplot(data=mpg, x=class, y=hwy, geom=&#39;line&#39;, color=class) 2.6 hist R have basic histplot function. We can use this by calling hist(). hist means histogram. It shows the distribution of continuous(numeric) variable. hist(mpg$hwy) If you input categorical variable(ex. mpg$class) into hist function, it returns error that Error in hist.default(mpg$class) : 'x' must be numeric 2.7 is.na is.na() is the function that check whether the input has missing value or not. and the input can be vector, list, data.frame etc. names &lt;- c(&#39;Kim&#39;, &#39;Jay&#39;, &#39;toreto&#39;, NA) is.na(names) ## [1] FALSE FALSE FALSE TRUE we can count NA by using table function. table(is.na(names)) ## ## FALSE TRUE ## 3 1 How about a dataframe? id &lt;- c(&#39;0000&#39;, &#39;0010&#39;, &#39;0022&#39;, NA) birth &lt;- c(&#39;880201&#39;, &#39;000106&#39;, &#39;930128&#39;, NA) customer_df &lt;- data.frame(names, id, birth) customer_df ## names id birth ## 1 Kim 0000 880201 ## 2 Jay 0010 000106 ## 3 toreto 0022 930128 ## 4 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; table(is.na(customer_df)) ## ## FALSE TRUE ## 9 3 we can visualize table by using plot() method plot(table(is.na(customer_df))) If we just need to check only NA, we can use sum(). sum(is.na(customer_df)) ## [1] 3 There are many ways to fill NA. first, just fill NA as specific value. customer_df[4,][&#39;names&#39;] &lt;- &#39;haword&#39; customer_df ## names id birth ## 1 Kim 0000 880201 ## 2 Jay 0010 000106 ## 3 toreto 0022 930128 ## 4 haword &lt;NA&gt; &lt;NA&gt; or we can use ifelse() function like this. ifelse(is.na(customer_df$id), &#39;Missing&#39;, customer_df$id) ## [1] &quot;0000&quot; &quot;0010&quot; &quot;0022&quot; &quot;Missing&quot; 2.8 na.omit or we can delete all missing values. customer_df &lt;- na.omit(customer_df) customer_df ## names id birth ## 1 Kim 0000 880201 ## 2 Jay 0010 000106 ## 3 toreto 0022 930128 2.9 barplot In case of outliers are in data frame, we have to select how to handle this outliers. If you have great domain knowledge, you can just use visualization and judge whether this value is outlier or not. height &lt;- c(180, 177, 17) customer_df$height &lt;- height barplot(customer_df$height, names=customer_df$names) is that right? is Toreto’s height 17(cm)? No. It’s may be typing error. maybe it’s 170, 177 etc. In many case, there are so many data in dataset so that it’s hard to check one by one through table, so it’s so useful to use visualization. 2.10 boxplot Especially when you do not have deep domain knowledge or want to look for statistical outliers, boxplot is a great help. boxplot(mpg$cty) We can see 4 outliers in boxplot. let’s check them. head(mpg) ## # A tibble: 6 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa… ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa… ## 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa… ## 4 audi a4 2 2008 4 auto(av) f 21 30 p compa… ## 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compa… ## 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compa… library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union mpg %&gt;% select(manufacturer, model, year, cty) %&gt;% arrange(desc(cty)) %&gt;% head(10) ## # A tibble: 10 x 4 ## manufacturer model year cty ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 volkswagen new beetle 1999 35 ## 2 volkswagen jetta 1999 33 ## 3 volkswagen new beetle 1999 29 ## 4 honda civic 1999 28 ## 5 toyota corolla 2008 28 ## 6 honda civic 2008 26 ## 7 toyota corolla 1999 26 ## 8 toyota corolla 2008 26 ## 9 honda civic 1999 25 ## 10 honda civic 2008 25 summary(mpg$cty) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 9.00 14.00 17.00 16.86 19.00 35.00 We can also extract boxplot’s output as numerical values. boxplot(mpg$cty)$out ## [1] 28 28 33 35 29 And let’s check this values from our dataframe. outputs &lt;- boxplot(mpg$cty)$out mpg[mpg$cty %in% outputs, ] ## # A tibble: 5 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 honda civic 1.6 1999 4 manual… f 28 33 r subcom… ## 2 toyota corolla 1.8 2008 4 manual… f 28 37 r compact ## 3 volkswagen jetta 1.9 1999 4 manual… f 33 44 d compact ## 4 volkswagen new be… 1.9 1999 4 manual… f 35 44 d subcom… ## 5 volkswagen new be… 1.9 1999 4 auto(l… f 29 41 d subcom… 2.11 ggplot2 :: ggplot ggplot2 is a package that helps with structural visualization using the R. scatter plot, box plot, line plot, hist plot etc. all type of chart that we discussed can all be used in ggplot. Let’s try it. head(mpg) ## # A tibble: 6 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa… ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa… ## 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa… ## 4 audi a4 2 2008 4 auto(av) f 21 30 p compa… ## 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compa… ## 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compa… library(ggplot2) ggplot(data=mpg, aes(x=year, y=cty)) + geom_point() Scatter plot is useful for checking distribution of dataset. But in this case, the year variable isn’t continuous. Let’s deal with other variable. ggplot(data=mpg, aes(x=displ, y=cty)) + geom_point() As with this one, if the two variables are not continuous, you should consider another chart. As another example, ggplot(data=mpg, aes(x=class, y=cty)) + geom_point() It is better to use a box plot to compare the fuel efficiency of each class. ggplot(data=mpg, aes(x=class, y=cty)) + geom_boxplot() "],["data-preprocessing.html", "Chapter 3 Data Preprocessing 3.1 ifelse 3.2 dplyr :: mutate 3.3 dplyr :: filter 3.4 dplyr :: select 3.5 dplyr :: arrange 3.6 dplyr :: summarise 3.7 dplyr :: left_join 3.8 dplyr :: right_join 3.9 dplyr :: inner_join 3.10 dplyr :: full_join 3.11 dplyr :: bind_cols 3.12 dplyr :: bind_rows", " Chapter 3 Data Preprocessing While exploring data, we need to preprocess it properly for our purpose. And these work can be repeat until we construct a dataset that can make our probabilistic model well. 3.1 ifelse ifelse is Conditional Statments function that is very simple and useful in R. We can use this with just 3 parameters - condition, return value when it’s true, return value when it’s false. let’s see example code. first, print the head of dataset head(mpg$hwy) ## [1] 29 29 31 30 26 26 And let’s apply ifelse to this head. if the hwy(highway fuel efficiency) is higher than 30, returns ‘Good.’ ifelse(head(mpg$hwy) &gt; 30, &#39;Good&#39;, &#39;Bad&#39;) ## [1] &quot;Bad&quot; &quot;Bad&quot; &quot;Good&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; We can use this data by assign method(&lt;-). Let’s Control Entire variable. evaluate_hwy &lt;- ifelse(mpg$hwy &gt; 30, &#39;Good&#39;, &#39;Bad&#39;) print(evaluate_hwy) ## [1] &quot;Bad&quot; &quot;Bad&quot; &quot;Good&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [11] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [21] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [31] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [41] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [51] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [61] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [71] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [81] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [91] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Good&quot; ## [101] &quot;Good&quot; &quot;Good&quot; &quot;Bad&quot; &quot;Good&quot; &quot;Good&quot; &quot;Good&quot; &quot;Good&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [111] &quot;Bad&quot; &quot;Good&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [121] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [131] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [141] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Good&quot; &quot;Good&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [151] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [161] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [171] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [181] &quot;Bad&quot; &quot;Good&quot; &quot;Good&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Good&quot; &quot;Good&quot; ## [191] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Good&quot; &quot;Good&quot; &quot;Good&quot; &quot;Good&quot; &quot;Bad&quot; &quot;Bad&quot; ## [201] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [211] &quot;Bad&quot; &quot;Bad&quot; &quot;Good&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [221] &quot;Bad&quot; &quot;Good&quot; &quot;Good&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [231] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; Then, Why is this necessary? Sometimes we need categorical data(nominal data or ordinal data) for not only visualization but also data handling. Especially, We do not always get gaussian distribution dataset, so since the data is not uniform, it is necessary to divide it into appropriate intervals. We can use this function to not only create new variable but also add another column. df_mpg &lt;- mpg df_mpg[&#39;eval_hwy&#39;] &lt;- ifelse(df_mpg$hwy&gt;30, &#39;High&#39;, &#39;Low&#39;) df_mpg$eval_hwy ## [1] &quot;Low&quot; &quot;Low&quot; &quot;High&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [11] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [21] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [31] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [41] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [51] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [61] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [71] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [81] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [91] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;High&quot; ## [101] &quot;High&quot; &quot;High&quot; &quot;Low&quot; &quot;High&quot; &quot;High&quot; &quot;High&quot; &quot;High&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [111] &quot;Low&quot; &quot;High&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [121] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [131] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [141] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;High&quot; &quot;High&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [151] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [161] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [171] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [181] &quot;Low&quot; &quot;High&quot; &quot;High&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;High&quot; &quot;High&quot; ## [191] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;High&quot; &quot;High&quot; &quot;High&quot; &quot;High&quot; &quot;Low&quot; &quot;Low&quot; ## [201] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [211] &quot;Low&quot; &quot;Low&quot; &quot;High&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [221] &quot;Low&quot; &quot;High&quot; &quot;High&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [231] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; 3.2 dplyr :: mutate In R, dplyr package is the most popular library for data preprocessing. Especially it provides pipe(‘%&gt;%’), and it’s very helpful for intuitive coding. And mutate in dplyr package do exactly same work as the one above, However it is simpler and easier to use. Let’s see this. (before load, you have to install “dplyr” package) # install.packages(&quot;dplyr&quot;) library(dplyr) head(df_mpg) ## # A tibble: 6 x 12 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa… ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa… ## 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa… ## 4 audi a4 2 2008 4 auto(av) f 21 30 p compa… ## 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compa… ## 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compa… ## # … with 1 more variable: eval_hwy &lt;chr&gt; We’ll use mutate function and pipe syntex to handle cty(city fuel economy) column. df_mpg %&gt;% mutate(mean_fuel = (cty + hwy)/2) %&gt;% head ## # A tibble: 6 x 13 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa… ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa… ## 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa… ## 4 audi a4 2 2008 4 auto(av) f 21 30 p compa… ## 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compa… ## 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compa… ## # … with 2 more variables: eval_hwy &lt;chr&gt;, mean_fuel &lt;dbl&gt; We can see the last column is added and named with mean_fuel. We didn’t have to use the name of dataframa(df_mpg) repeatly to use columns. It’s very nice. And of course we can use ifelse function with the pipe and mutate. df_mpg %&gt;% mutate(mean_fuel = (cty + hwy)/2, eval_fuel = ifelse(mean_fuel &gt; 20, &#39;high&#39;, &#39;low&#39;)) %&gt;% head ## # A tibble: 6 x 14 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa… ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa… ## 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa… ## 4 audi a4 2 2008 4 auto(av) f 21 30 p compa… ## 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compa… ## 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compa… ## # … with 3 more variables: eval_hwy &lt;chr&gt;, mean_fuel &lt;dbl&gt;, eval_fuel &lt;chr&gt; If you want to use this data table continuously, you have to assign this table to the new variable like this. new_mpg &lt;- df_mpg %&gt;% mutate(mean_fuel = (cty + hwy)/2, eval_fuel = ifelse(mean_fuel &gt; 20, &#39;high&#39;, &#39;low&#39;)) str(new_mpg) ## tibble [234 × 14] (S3: tbl_df/tbl/data.frame) ## $ manufacturer: chr [1:234] &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; ... ## $ model : chr [1:234] &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; ... ## $ displ : num [1:234] 1.8 1.8 2 2 2.8 2.8 3.1 1.8 1.8 2 ... ## $ year : int [1:234] 1999 1999 2008 2008 1999 1999 2008 1999 1999 2008 ... ## $ cyl : int [1:234] 4 4 4 4 6 6 6 4 4 4 ... ## $ trans : chr [1:234] &quot;auto(l5)&quot; &quot;manual(m5)&quot; &quot;manual(m6)&quot; &quot;auto(av)&quot; ... ## $ drv : chr [1:234] &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; ... ## $ cty : int [1:234] 18 21 20 21 16 18 18 18 16 20 ... ## $ hwy : int [1:234] 29 29 31 30 26 26 27 26 25 28 ... ## $ fl : chr [1:234] &quot;p&quot; &quot;p&quot; &quot;p&quot; &quot;p&quot; ... ## $ class : chr [1:234] &quot;compact&quot; &quot;compact&quot; &quot;compact&quot; &quot;compact&quot; ... ## $ eval_hwy : chr [1:234] &quot;Low&quot; &quot;Low&quot; &quot;High&quot; &quot;Low&quot; ... ## $ mean_fuel : num [1:234] 23.5 25 25.5 25.5 21 22 22.5 22 20.5 24 ... ## $ eval_fuel : chr [1:234] &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; ... qplot(new_mpg$mean_fuel) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. qplot(new_mpg$eval_fuel) We can use more functions from dplyr package. The commonly used functions that except mutate we have seen already are filter(), select(), arrange(), summarise(). Let’s look at these one by one. 3.3 dplyr :: filter First, filter() function. filter extracts rows by some conditions. head(new_mpg) ## # A tibble: 6 x 14 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa… ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa… ## 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa… ## 4 audi a4 2 2008 4 auto(av) f 21 30 p compa… ## 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compa… ## 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compa… ## # … with 3 more variables: eval_hwy &lt;chr&gt;, mean_fuel &lt;dbl&gt;, eval_fuel &lt;chr&gt; If you want to extract only audi, you can use filter. new_mpg %&gt;% filter(manufacturer==&#39;audi&#39;) ## # A tibble: 18 x 14 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l… f 18 29 p comp… ## 2 audi a4 1.8 1999 4 manual… f 21 29 p comp… ## 3 audi a4 2 2008 4 manual… f 20 31 p comp… ## 4 audi a4 2 2008 4 auto(a… f 21 30 p comp… ## 5 audi a4 2.8 1999 6 auto(l… f 16 26 p comp… ## 6 audi a4 2.8 1999 6 manual… f 18 26 p comp… ## 7 audi a4 3.1 2008 6 auto(a… f 18 27 p comp… ## 8 audi a4 quat… 1.8 1999 4 manual… 4 18 26 p comp… ## 9 audi a4 quat… 1.8 1999 4 auto(l… 4 16 25 p comp… ## 10 audi a4 quat… 2 2008 4 manual… 4 20 28 p comp… ## 11 audi a4 quat… 2 2008 4 auto(s… 4 19 27 p comp… ## 12 audi a4 quat… 2.8 1999 6 auto(l… 4 15 25 p comp… ## 13 audi a4 quat… 2.8 1999 6 manual… 4 17 25 p comp… ## 14 audi a4 quat… 3.1 2008 6 auto(s… 4 17 25 p comp… ## 15 audi a4 quat… 3.1 2008 6 manual… 4 15 25 p comp… ## 16 audi a6 quat… 2.8 1999 6 auto(l… 4 15 24 p mids… ## 17 audi a6 quat… 3.1 2008 6 auto(s… 4 17 25 p mids… ## 18 audi a6 quat… 4.2 2008 8 auto(s… 4 16 23 p mids… ## # … with 3 more variables: eval_hwy &lt;chr&gt;, mean_fuel &lt;dbl&gt;, eval_fuel &lt;chr&gt; If you want to extract audi a4 model, new_mpg %&gt;% filter(manufacturer==&#39;audi&#39; &amp; model==&#39;a4&#39;) ## # A tibble: 7 x 14 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa… ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa… ## 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa… ## 4 audi a4 2 2008 4 auto(av) f 21 30 p compa… ## 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compa… ## 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compa… ## 7 audi a4 3.1 2008 6 auto(av) f 18 27 p compa… ## # … with 3 more variables: eval_hwy &lt;chr&gt;, mean_fuel &lt;dbl&gt;, eval_fuel &lt;chr&gt; If you want to extract audi a4 that have Good for highway fuel economy, new_mpg %&gt;% filter(manufacturer==&#39;audi&#39; &amp; model==&#39;a4&#39; &amp; eval_hwy == &#39;High&#39;) ## # A tibble: 1 x 14 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 2 2008 4 manual(m6) f 20 31 p compa… ## # … with 3 more variables: eval_hwy &lt;chr&gt;, mean_fuel &lt;dbl&gt;, eval_fuel &lt;chr&gt; Yes, now you can choose the car that you want. 3.4 dplyr :: select Next, select() function. We have used filter() to extract rows, now we’ll use select() to extract columns. new_mpg %&gt;% select(manufacturer) %&gt;% head ## # A tibble: 6 x 1 ## manufacturer ## &lt;chr&gt; ## 1 audi ## 2 audi ## 3 audi ## 4 audi ## 5 audi ## 6 audi Two or more columns can be extracted at the same time. new_mpg %&gt;% select(manufacturer, class, hwy) %&gt;% head ## # A tibble: 6 x 3 ## manufacturer class hwy ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 audi compact 29 ## 2 audi compact 29 ## 3 audi compact 31 ## 4 audi compact 30 ## 5 audi compact 26 ## 6 audi compact 26 And with pipe, we can extract some rows and some columns at the same time too. new_mpg %&gt;% select(manufacturer, model, class, hwy) %&gt;% filter(hwy &gt; 23) %&gt;% head(10) ## # A tibble: 10 x 4 ## manufacturer model class hwy ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 audi a4 compact 29 ## 2 audi a4 compact 29 ## 3 audi a4 compact 31 ## 4 audi a4 compact 30 ## 5 audi a4 compact 26 ## 6 audi a4 compact 26 ## 7 audi a4 compact 27 ## 8 audi a4 quattro compact 26 ## 9 audi a4 quattro compact 25 ## 10 audi a4 quattro compact 28 3.5 dplyr :: arrange In case of numerical data(variable), we can order it. If data is categorical variable, It’ll return error. new_mpg %&gt;% select(manufacturer, model, class, hwy) %&gt;% arrange(hwy) %&gt;% head(10) ## # A tibble: 10 x 4 ## manufacturer model class hwy ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 dodge dakota pickup 4wd pickup 12 ## 2 dodge durango 4wd suv 12 ## 3 dodge ram 1500 pickup 4wd pickup 12 ## 4 dodge ram 1500 pickup 4wd pickup 12 ## 5 jeep grand cherokee 4wd suv 12 ## 6 chevrolet k1500 tahoe 4wd suv 14 ## 7 jeep grand cherokee 4wd suv 14 ## 8 chevrolet c1500 suburban 2wd suv 15 ## 9 chevrolet k1500 tahoe 4wd suv 15 ## 10 dodge dakota pickup 4wd pickup 15 If you want to sort dataset from highest to lowest highway fuel economy, wrapping arrange variable by desc() new_mpg %&gt;% select(manufacturer, model, class, hwy) %&gt;% arrange(desc(hwy)) %&gt;% head(10) ## # A tibble: 10 x 4 ## manufacturer model class hwy ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 volkswagen jetta compact 44 ## 2 volkswagen new beetle subcompact 44 ## 3 volkswagen new beetle subcompact 41 ## 4 toyota corolla compact 37 ## 5 honda civic subcompact 36 ## 6 honda civic subcompact 36 ## 7 toyota corolla compact 35 ## 8 toyota corolla compact 35 ## 9 honda civic subcompact 34 ## 10 honda civic subcompact 33 3.6 dplyr :: summarise The function summarise() can be used to get basic statistics by specifying functions such as mean(), sd(), median(), etc. new_mpg %&gt;% filter(manufacturer==&#39;audi&#39;) %&gt;% summarise(mean_hwy = mean(hwy)) ## # A tibble: 1 x 1 ## mean_hwy ## &lt;dbl&gt; ## 1 26.4 head(10) ## [1] 10 new_mpg %&gt;% filter(manufacturer==&#39;audi&#39;) %&gt;% summarise(mean_hwy = mean(hwy), max_hwy = max(hwy), min_hwy = min(hwy)) ## # A tibble: 1 x 3 ## mean_hwy max_hwy min_hwy ## &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 26.4 31 23 head(10) ## [1] 10 But, this function can be more useful if used together with groupby. new_mpg %&gt;% group_by(manufacturer) %&gt;% summarise(mean_hwy = mean(hwy), max_hwy = max(hwy), min_hwy = min(hwy)) ## # A tibble: 15 x 4 ## manufacturer mean_hwy max_hwy min_hwy ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 audi 26.4 31 23 ## 2 chevrolet 21.9 30 14 ## 3 dodge 17.9 24 12 ## 4 ford 19.4 26 15 ## 5 honda 32.6 36 29 ## 6 hyundai 26.9 31 24 ## 7 jeep 17.6 22 12 ## 8 land rover 16.5 18 15 ## 9 lincoln 17 18 16 ## 10 mercury 18 19 17 ## 11 nissan 24.6 32 17 ## 12 pontiac 26.4 28 25 ## 13 subaru 25.6 27 23 ## 14 toyota 24.9 37 15 ## 15 volkswagen 29.2 44 23 we can apply arrange() too. new_mpg %&gt;% group_by(manufacturer) %&gt;% summarise(mean_hwy = mean(hwy), max_hwy = max(hwy), min_hwy = min(hwy)) %&gt;% arrange(desc(mean_hwy)) ## # A tibble: 15 x 4 ## manufacturer mean_hwy max_hwy min_hwy ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 honda 32.6 36 29 ## 2 volkswagen 29.2 44 23 ## 3 hyundai 26.9 31 24 ## 4 audi 26.4 31 23 ## 5 pontiac 26.4 28 25 ## 6 subaru 25.6 27 23 ## 7 toyota 24.9 37 15 ## 8 nissan 24.6 32 17 ## 9 chevrolet 21.9 30 14 ## 10 ford 19.4 26 15 ## 11 mercury 18 19 17 ## 12 dodge 17.9 24 12 ## 13 jeep 17.6 22 12 ## 14 lincoln 17 18 16 ## 15 land rover 16.5 18 15 We select 2 or more columns to group_by function like this. new_mpg %&gt;% group_by(manufacturer, model) %&gt;% summarise(mean_hwy = mean(hwy), max_hwy = max(hwy), min_hwy = min(hwy)) ## `summarise()` has grouped output by &#39;manufacturer&#39;. You can override using the `.groups` argument. ## # A tibble: 38 x 5 ## # Groups: manufacturer [15] ## manufacturer model mean_hwy max_hwy min_hwy ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 audi a4 28.3 31 26 ## 2 audi a4 quattro 25.8 28 25 ## 3 audi a6 quattro 24 25 23 ## 4 chevrolet c1500 suburban 2wd 17.8 20 15 ## 5 chevrolet corvette 24.8 26 23 ## 6 chevrolet k1500 tahoe 4wd 16.2 19 14 ## 7 chevrolet malibu 27.6 30 26 ## 8 dodge caravan 2wd 22.4 24 17 ## 9 dodge dakota pickup 4wd 17 19 12 ## 10 dodge durango 4wd 16 18 12 ## # … with 28 more rows and apply filter() too. new_mpg %&gt;% group_by(manufacturer, model) %&gt;% summarise(mean_hwy = mean(hwy), max_hwy = max(hwy), min_hwy = min(hwy)) %&gt;% filter(manufacturer==&#39;audi&#39; | manufacturer==&#39;hyundai&#39;) ## `summarise()` has grouped output by &#39;manufacturer&#39;. You can override using the `.groups` argument. ## # A tibble: 5 x 5 ## # Groups: manufacturer [2] ## manufacturer model mean_hwy max_hwy min_hwy ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 audi a4 28.3 31 26 ## 2 audi a4 quattro 25.8 28 25 ## 3 audi a6 quattro 24 25 23 ## 4 hyundai sonata 27.7 31 26 ## 5 hyundai tiburon 26 29 24 3.7 dplyr :: left_join dplyr package contain join functions. First, we try left_join() for our custom data. students &lt;- c(&#39;Jennie&#39;, &#39;Tom&#39;, &#39;Minsu&#39;, &#39;Jay&#39;, &#39;Bob&#39;) classes &lt;- c(&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;) keys &lt;- c(&#39;JN&#39;, &#39;T&#39;, &#39;M&#39;, &#39;J&#39;, &#39;B&#39;) heights &lt;- c(155, 190, 165, 177, 180) weights &lt;- c(57, 101, 64, 80, 88) class_info &lt;- data.frame(students, classes) students_info &lt;- data.frame(students, keys, heights, weights) head(class_info) ## students classes ## 1 Jennie A ## 2 Tom B ## 3 Minsu C ## 4 Jay D ## 5 Bob E head(students_info) ## students keys heights weights ## 1 Jennie JN 155 57 ## 2 Tom T 190 101 ## 3 Minsu M 165 64 ## 4 Jay J 177 80 ## 5 Bob B 180 88 If we have to combine this two table, We need some “point”s. This means some “column”s that two table have in common. In this example, students column is that. Let’s combine datasets by Setting students column as a point. all_info &lt;- left_join(class_info, students_info, by=&#39;students&#39;) all_info ## students classes keys heights weights ## 1 Jennie A JN 155 57 ## 2 Tom B T 190 101 ## 3 Minsu C M 165 64 ## 4 Jay D J 177 80 ## 5 Bob E B 180 88 3.8 dplyr :: right_join What if we use right_join()? In this table, it’s same. all_info2 &lt;- right_join(class_info, students_info, by=&#39;students&#39;) all_info2 ## students classes keys heights weights ## 1 Jennie A JN 155 57 ## 2 Tom B T 190 101 ## 3 Minsu C M 165 64 ## 4 Jay D J 177 80 ## 5 Bob E B 180 88 Because left table(class_info) and right rable(students_info) have same variable(students). If one side has Na in students column, the result will be different. students_info2 &lt;- students_info[-1,] students_info2 ## students keys heights weights ## 2 Tom T 190 101 ## 3 Minsu M 165 64 ## 4 Jay J 177 80 ## 5 Bob B 180 88 all_info3 &lt;- left_join(class_info, students_info2, by=&#39;students&#39;) all_info3 ## students classes keys heights weights ## 1 Jennie A &lt;NA&gt; NA NA ## 2 Tom B T 190 101 ## 3 Minsu C M 165 64 ## 4 Jay D J 177 80 ## 5 Bob E B 180 88 let’s see this. We have founded 3 NA values. It’s bacause students_info2 didn’t have the Jennie’s informatino(row) But, all_info4 &lt;- right_join(class_info, students_info2, by=&#39;students&#39;) all_info4 ## students classes keys heights weights ## 1 Tom B T 190 101 ## 2 Minsu C M 165 64 ## 3 Jay D J 177 80 ## 4 Bob E B 180 88 If we have chosen right_join() at this moment, we can get different result like this. It’s because students_info2 didn’t have the Jennie’s informatino(row). Same. right_join() receives two inputs like left_join(), and joins tables based on the right (second) input. 3.9 dplyr :: inner_join How can we join tables if we met all of tables are have NA at base column of reference? Like this case, class_info2 &lt;- class_info[-2,] class_info2 ## students classes ## 1 Jennie A ## 3 Minsu C ## 4 Jay D ## 5 Bob E all_info4 &lt;- left_join(class_info2, students_info2, by=&#39;students&#39;) all_info4 ## students classes keys heights weights ## 1 Jennie A &lt;NA&gt; NA NA ## 2 Minsu C M 165 64 ## 3 Jay D J 177 80 ## 4 Bob E B 180 88 all_info5 &lt;- right_join(class_info2, students_info2, by=&#39;students&#39;) all_info5 ## students classes keys heights weights ## 1 Minsu C M 165 64 ## 2 Jay D J 177 80 ## 3 Bob E B 180 88 ## 4 Tom &lt;NA&gt; T 190 101 Yes, returns have NA all as expected. But we want to get result that without missing value. In this case, we can use inner_join() all_info6 &lt;- inner_join(class_info2, students_info2, by=&#39;students&#39;) all_info6 ## students classes keys heights weights ## 1 Minsu C M 165 64 ## 2 Jay D J 177 80 ## 3 Bob E B 180 88 3.10 dplyr :: full_join Conversely, if we want to display all values together even if there are missing values in left or right, we can use full_join() all_info7 &lt;- full_join(class_info2, students_info2, by=&#39;students&#39;) all_info7 ## students classes keys heights weights ## 1 Jennie A &lt;NA&gt; NA NA ## 2 Minsu C M 165 64 ## 3 Jay D J 177 80 ## 4 Bob E B 180 88 ## 5 Tom &lt;NA&gt; T 190 101 3.11 dplyr :: bind_cols If two data tables have the same number of rows, you can use bind_cols(). It is simple and return different result from join. bind_cols(class_info2, students_info2) ## New names: ## * students -&gt; students...1 ## * students -&gt; students...3 ## students...1 classes students...3 keys heights weights ## 1 Jennie A Tom T 190 101 ## 2 Minsu C Minsu M 165 64 ## 3 Jay D Jay J 177 80 ## 4 Bob E Bob B 180 88 Yes, it just concatenate two tables. There is no reference column. So, same number of rows should be noted. If each number of rows are different, It returns error. class_info ## students classes ## 1 Jennie A ## 2 Tom B ## 3 Minsu C ## 4 Jay D ## 5 Bob E students_info2 ## students keys heights weights ## 2 Tom T 190 101 ## 3 Minsu M 165 64 ## 4 Jay J 177 80 ## 5 Bob B 180 88 bind_cols(class_info, students_info2) ## Error: Can&#39;t recycle `..1` (size 5) to match `..2` (size 4). Run `rlang::last_error()` to see where the error occurred. 3.12 dplyr :: bind_rows Unlike bind_cols(), it can join tables with different columns. fruit &lt;- c(&#39;apple&#39;, &#39;banana&#39;, &#39;watermelon&#39;, &#39;mango&#39;) berry &lt;- c(&#39;strawberry&#39;, &#39;raspberry&#39;, &#39;mulberry&#39;, &#39;wildberry&#39;) print(fruit) ## [1] &quot;apple&quot; &quot;banana&quot; &quot;watermelon&quot; &quot;mango&quot; print(berry) ## [1] &quot;strawberry&quot; &quot;raspberry&quot; &quot;mulberry&quot; &quot;wildberry&quot; fruit_df &lt;- data.frame(fruit) fruit_df ## fruit ## 1 apple ## 2 banana ## 3 watermelon ## 4 mango berry_df &lt;- data.frame(berry) berry_df ## berry ## 1 strawberry ## 2 raspberry ## 3 mulberry ## 4 wildberry fruit_df$sugar &lt;- c(3,8,2,9) berry_df$sugar &lt;- c(2,1,1,1) berry_df$color &lt;- c(&#39;red&#39;, &#39;red&#39;, &#39;black&#39;, &#39;red&#39;) print(fruit_df) ## fruit sugar ## 1 apple 3 ## 2 banana 8 ## 3 watermelon 2 ## 4 mango 9 print(berry_df) ## berry sugar color ## 1 strawberry 2 red ## 2 raspberry 1 red ## 3 mulberry 1 black ## 4 wildberry 1 red berry_df &lt;- rename(berry_df, fruit = berry) print(berry_df) ## fruit sugar color ## 1 strawberry 2 red ## 2 raspberry 1 red ## 3 mulberry 1 black ## 4 wildberry 1 red bind_rows(fruit_df, berry_df) ## fruit sugar color ## 1 apple 3 &lt;NA&gt; ## 2 banana 8 &lt;NA&gt; ## 3 watermelon 2 &lt;NA&gt; ## 4 mango 9 &lt;NA&gt; ## 5 strawberry 2 red ## 6 raspberry 1 red ## 7 mulberry 1 black ## 8 wildberry 1 red Yes, It returns data table without error even if the structure of column is different. And of course, the number of rows doesn’t matter, since we’re joining rows. But let’s check them too. bind_rows(fruit_df, berry_df[-1,]) ## fruit sugar color ## 1 apple 3 &lt;NA&gt; ## 2 banana 8 &lt;NA&gt; ## 3 watermelon 2 &lt;NA&gt; ## 4 mango 9 &lt;NA&gt; ## 5 raspberry 1 red ## 6 mulberry 1 black ## 7 wildberry 1 red Okay, Just one row decreased. "],["references.html", "References", " References "]]
