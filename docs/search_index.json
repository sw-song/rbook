[["index.html", "R Note Intro to R", " R Note Seungwon Song Update - 2021-07-14 Intro to R R is one of the best language for statistics. Sometimes it is compared with python. Python is nice tool for data analysis, especially machine learning or deep learning. But being able to handle R will gives anyone who works with data and statistics another huge advantage. This note will not cover too detailed grammar, internal principles, or advanced techniques. However, it focuses on how to handle data through R even if you do not know R syntax. Then, let’s start lightly! "],["exploratory-data-analysis.html", "Chapter 1 Exploratory Data Analysis 1.1 head and tail 1.2 dim and str 1.3 summary 1.4 table 1.5 qplot 1.6 hist 1.7 is.na 1.8 na.omit 1.9 barplot 1.10 baxplot", " Chapter 1 Exploratory Data Analysis EDA(Exploratory Data Analysis) is necessary for data analyst to check the dataset before statistical modeling(or machine learning) 1.1 head and tail df_mpg &lt;- data.frame(ggplot2::mpg) head(df_mpg) ## manufacturer model displ year cyl trans drv cty hwy fl class ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compact ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compact ## 3 audi a4 2.0 2008 4 manual(m6) f 20 31 p compact ## 4 audi a4 2.0 2008 4 auto(av) f 21 30 p compact ## 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compact ## 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compact we have loaded mpg dataset from ggplot2 package. ggplot2 contains multiple useful datasets and various visualization tools. head function extract top 6 rows of input dataset. In contrast, we can extract bottom 6 rows using tail function. tail(df_mpg) ## manufacturer model displ year cyl trans drv cty hwy fl class ## 229 volkswagen passat 1.8 1999 4 auto(l5) f 18 29 p midsize ## 230 volkswagen passat 2.0 2008 4 auto(s6) f 19 28 p midsize ## 231 volkswagen passat 2.0 2008 4 manual(m6) f 21 29 p midsize ## 232 volkswagen passat 2.8 1999 6 auto(l5) f 16 26 p midsize ## 233 volkswagen passat 2.8 1999 6 manual(m5) f 18 26 p midsize ## 234 volkswagen passat 3.6 2008 6 auto(s6) f 17 26 p midsize It’s important to check rows in this way, because most of dataset we meet are so large that it can’t be shown just in one page. 1.2 dim and str using dim function, we can check the size of dataset. The size means rows x columns. dim(df_mpg) ## [1] 234 11 This mpg dataset has 234 rows and 11 columns(features). We do not need to use this function just for check entire dataset. dim(head(df_mpg)) ## [1] 6 11 dim(df_mpg[,2:4]) ## [1] 234 3 dim(df_mpg[&#39;model&#39;]) ## [1] 234 1 but we can’t use dim for 1-dim vector. Note that df_mpg[‘model’] is not a vector, it’s dataframe yet. str(df_mpg[&#39;model&#39;]) ## &#39;data.frame&#39;: 234 obs. of 1 variable: ## $ model: chr &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; ... It’s different from df_mpg$model str(df_mpg$model) ## chr [1:234] &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4 quattro&quot; &quot;a4 quattro&quot; ... This is vector. And it’s same with df_mpg[[‘model’]] str(df_mpg[[&#39;model&#39;]]) ## chr [1:234] &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4 quattro&quot; &quot;a4 quattro&quot; ... 1.3 summary we can check summary statistics using summary function. summary(df_mpg) ## manufacturer model displ year ## Length:234 Length:234 Min. :1.600 Min. :1999 ## Class :character Class :character 1st Qu.:2.400 1st Qu.:1999 ## Mode :character Mode :character Median :3.300 Median :2004 ## Mean :3.472 Mean :2004 ## 3rd Qu.:4.600 3rd Qu.:2008 ## Max. :7.000 Max. :2008 ## cyl trans drv cty ## Min. :4.000 Length:234 Length:234 Min. : 9.00 ## 1st Qu.:4.000 Class :character Class :character 1st Qu.:14.00 ## Median :6.000 Mode :character Mode :character Median :17.00 ## Mean :5.889 Mean :16.86 ## 3rd Qu.:8.000 3rd Qu.:19.00 ## Max. :8.000 Max. :35.00 ## hwy fl class ## Min. :12.00 Length:234 Length:234 ## 1st Qu.:18.00 Class :character Class :character ## Median :24.00 Mode :character Mode :character ## Mean :23.44 ## 3rd Qu.:27.00 ## Max. :44.00 If column is categorical variable, like model, trans, drv, manufacturer, fl, class, it just shows Length, Class and Mode. But in case of numerical, it can shows mean of variable, median of variable, minimum of variable, maximum of variable and 1st and 3rd quartile. 1.4 table And R also provides a frequency table. We can use this as call table function. table(df_mpg$model) ## ## 4runner 4wd a4 a4 quattro ## 6 7 8 ## a6 quattro altima c1500 suburban 2wd ## 3 6 5 ## camry camry solara caravan 2wd ## 7 7 11 ## civic corolla corvette ## 9 5 5 ## dakota pickup 4wd durango 4wd expedition 2wd ## 9 7 3 ## explorer 4wd f150 pickup 4wd forester awd ## 6 7 6 ## grand cherokee 4wd grand prix gti ## 8 5 5 ## impreza awd jetta k1500 tahoe 4wd ## 8 9 4 ## land cruiser wagon 4wd malibu maxima ## 2 5 3 ## mountaineer 4wd mustang navigator 2wd ## 4 9 3 ## new beetle passat pathfinder 4wd ## 6 7 4 ## ram 1500 pickup 4wd range rover sonata ## 10 4 7 ## tiburon toyota tacoma 4wd ## 7 7 table(df_mpg$class) ## ## 2seater compact midsize minivan pickup subcompact suv ## 5 47 41 11 33 35 62 It’s helpful to check counts of each values in variable. To better use, we can use this table with visualizing original variable. first, let’s import ggplot2 library library(ggplot2) qplot(df_mpg$class) You should be careful to visualize the table as it is. If you visualize the table, it shows the different one. qplot(table(df_mpg$class)) ## Don&#39;t know how to automatically pick scale for object of type table. Defaulting to continuous. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 1.5 qplot Visualization is always important part for EDA. Let’s study more about qplot. we use mpg dataset. Extract top 5 rows head(mpg) ## # A tibble: 6 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa… ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa… ## 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa… ## 4 audi a4 2 2008 4 auto(av) f 21 30 p compa… ## 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compa… ## 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compa… qplot means “quick plot.” It is useful for quickly running our plot. let’s see some feature’s frequency using qplot qplot(data=mpg, x=manufacturer) qplot(data=mpg, x=fl) qplot(data=mpg, x=year) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. it’s weired. year data have only 2 cases. let’s check that. table(mpg$year) ## ## 1999 2008 ## 117 117 yes. it’s contain only the car data that manufacturered in 1999 and 2008. We have to think about this when analysis this dataset. and let’s go ahead and check the other feature one more. qplot(data=mpg, x=class) like this, we can show data’s frequency by input x(feature). and class contains types of car like size or shape etc. table(mpg$class) ## ## 2seater compact midsize minivan pickup subcompact suv ## 5 47 41 11 33 35 62 Then, what will happen if we input y into qplot function? qplot(data=mpg, x=class, y=hwy) This is scatter plot. From this plot, we can check highway fuel economy of each car class. Pick-up truck and SUV are not good at average fuel economy. But, we have more useful plot than scatter plot for checking the mean of data. Let’s use that. qplot(data=mpg, x=class, y=hwy, geom=&#39;boxplot&#39;, color=class) It’s box plot. We can check means easily and even outliers. It’s very important that how our data visualized and what tools we use. If we use line plot for this situation, It is difficult to accurately show the data. qplot(data=mpg, x=class, y=hwy, geom=&#39;line&#39;, color=class) 1.6 hist R have basic histplot function. We can use this by calling hist(). hist means histogram. It shows the distribution of continuous(numeric) variable. hist(mpg$hwy) If you input categorical variable(ex. mpg$class) into hist function, it returns error that Error in hist.default(mpg$class) : 'x' must be numeric 1.7 is.na is.na() is the function that check whether the input has missing value or not. and the input can be vector, list, data.frame etc. names &lt;- c(&#39;Kim&#39;, &#39;Jay&#39;, &#39;toreto&#39;, NA) is.na(names) ## [1] FALSE FALSE FALSE TRUE we can count NA by using table function. table(is.na(names)) ## ## FALSE TRUE ## 3 1 How about a dataframe? id &lt;- c(&#39;0000&#39;, &#39;0010&#39;, &#39;0022&#39;, NA) birth &lt;- c(&#39;880201&#39;, &#39;000106&#39;, &#39;930128&#39;, NA) customer_df &lt;- data.frame(names, id, birth) customer_df ## names id birth ## 1 Kim 0000 880201 ## 2 Jay 0010 000106 ## 3 toreto 0022 930128 ## 4 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; table(is.na(customer_df)) ## ## FALSE TRUE ## 9 3 we can visualize table by using plot() method plot(table(is.na(customer_df))) If we just need to check only NA, we can use sum(). sum(is.na(customer_df)) ## [1] 3 There are many ways to fill NA. first, just fill NA as specific value. customer_df[4,][&#39;names&#39;] &lt;- &#39;haword&#39; customer_df ## names id birth ## 1 Kim 0000 880201 ## 2 Jay 0010 000106 ## 3 toreto 0022 930128 ## 4 haword &lt;NA&gt; &lt;NA&gt; or we can use ifelse() function like this. ifelse(is.na(customer_df$id), &#39;Missing&#39;, customer_df$id) ## [1] &quot;0000&quot; &quot;0010&quot; &quot;0022&quot; &quot;Missing&quot; 1.8 na.omit or we can delete all missing values. customer_df &lt;- na.omit(customer_df) customer_df ## names id birth ## 1 Kim 0000 880201 ## 2 Jay 0010 000106 ## 3 toreto 0022 930128 1.9 barplot In case of outliers are in data frame, we have to select how to handle this outliers. If you have great domain knowledge, you can just use visualization and judge whether this value is outlier or not. height &lt;- c(180, 177, 17) customer_df$height &lt;- height barplot(customer_df$height, names=customer_df$names) is that right? is Toreto’s height 17(cm)? No. It’s may be typing error. maybe it’s 170, 177 etc. In many case, there are so many data in dataset so that it’s hard to check one by one through table, so it’s so useful to use visualization. 1.10 baxplot Especially when you do not have deep domain knowledge or want to look for statistical outliers, boxplot is a great help. boxplot(mpg$cty) We can see 4 outliers in boxplot. let’s check them. head(mpg) ## # A tibble: 6 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa… ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa… ## 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa… ## 4 audi a4 2 2008 4 auto(av) f 21 30 p compa… ## 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compa… ## 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compa… library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union mpg %&gt;% select(manufacturer, model, year, cty) %&gt;% arrange(desc(cty)) %&gt;% head(10) ## # A tibble: 10 x 4 ## manufacturer model year cty ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 volkswagen new beetle 1999 35 ## 2 volkswagen jetta 1999 33 ## 3 volkswagen new beetle 1999 29 ## 4 honda civic 1999 28 ## 5 toyota corolla 2008 28 ## 6 honda civic 2008 26 ## 7 toyota corolla 1999 26 ## 8 toyota corolla 2008 26 ## 9 honda civic 1999 25 ## 10 honda civic 2008 25 summary(mpg$cty) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 9.00 14.00 17.00 16.86 19.00 35.00 We can also extract boxplot’s output as numerical values. boxplot(mpg$cty)$out ## [1] 28 28 33 35 29 And let’s check this values from our dataframe. outputs &lt;- boxplot(mpg$cty)$out mpg[mpg$cty %in% outputs, ] ## # A tibble: 5 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 honda civic 1.6 1999 4 manual… f 28 33 r subcom… ## 2 toyota corolla 1.8 2008 4 manual… f 28 37 r compact ## 3 volkswagen jetta 1.9 1999 4 manual… f 33 44 d compact ## 4 volkswagen new be… 1.9 1999 4 manual… f 35 44 d subcom… ## 5 volkswagen new be… 1.9 1999 4 auto(l… f 29 41 d subcom… "],["data-preprocessing.html", "Chapter 2 Data Preprocessing 2.1 ifelse 2.2 dplyr :: mutate 2.3 dplyr :: filter 2.4 dplyr :: select 2.5 dplyr :: arrange 2.6 dplyr :: summarise 2.7 dplyr :: left_join 2.8 dplyr :: right_join 2.9 dplyr :: inner_join 2.10 dplyr :: full_join 2.11 dplyr :: bind_cols 2.12 dplyr :: bind_rows", " Chapter 2 Data Preprocessing While exploring data, we need to preprocess it properly for our purpose. And these work can be repeat until we construct a dataset that can make our probabilistic model well. 2.1 ifelse ifelse is Conditional Statments function that is very simple and useful in R. We can use this with just 3 parameters - condition, return value when it’s true, return value when it’s false. let’s see example code. first, print the head of dataset head(mpg$hwy) ## [1] 29 29 31 30 26 26 And let’s apply ifelse to this head. if the hwy(highway fuel efficiency) is higher than 30, returns ‘Good.’ ifelse(head(mpg$hwy) &gt; 30, &#39;Good&#39;, &#39;Bad&#39;) ## [1] &quot;Bad&quot; &quot;Bad&quot; &quot;Good&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; We can use this data by assign method(&lt;-). Let’s Control Entire variable. evaluate_hwy &lt;- ifelse(mpg$hwy &gt; 30, &#39;Good&#39;, &#39;Bad&#39;) print(evaluate_hwy) ## [1] &quot;Bad&quot; &quot;Bad&quot; &quot;Good&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [11] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [21] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [31] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [41] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [51] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [61] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [71] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [81] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [91] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Good&quot; ## [101] &quot;Good&quot; &quot;Good&quot; &quot;Bad&quot; &quot;Good&quot; &quot;Good&quot; &quot;Good&quot; &quot;Good&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [111] &quot;Bad&quot; &quot;Good&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [121] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [131] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [141] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Good&quot; &quot;Good&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [151] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [161] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [171] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [181] &quot;Bad&quot; &quot;Good&quot; &quot;Good&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Good&quot; &quot;Good&quot; ## [191] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Good&quot; &quot;Good&quot; &quot;Good&quot; &quot;Good&quot; &quot;Bad&quot; &quot;Bad&quot; ## [201] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [211] &quot;Bad&quot; &quot;Bad&quot; &quot;Good&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [221] &quot;Bad&quot; &quot;Good&quot; &quot;Good&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; ## [231] &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; &quot;Bad&quot; Then, Why is this necessary? Sometimes we need categorical data(nominal data or ordinal data) for not only visualization but also data handling. Especially, We do not always get gaussian distribution dataset, so since the data is not uniform, it is necessary to divide it into appropriate intervals. We can use this function to not only create new variable but also add another column. df_mpg &lt;- mpg df_mpg[&#39;eval_hwy&#39;] &lt;- ifelse(df_mpg$hwy&gt;30, &#39;High&#39;, &#39;Low&#39;) df_mpg$eval_hwy ## [1] &quot;Low&quot; &quot;Low&quot; &quot;High&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [11] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [21] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [31] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [41] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [51] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [61] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [71] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [81] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [91] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;High&quot; ## [101] &quot;High&quot; &quot;High&quot; &quot;Low&quot; &quot;High&quot; &quot;High&quot; &quot;High&quot; &quot;High&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [111] &quot;Low&quot; &quot;High&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [121] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [131] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [141] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;High&quot; &quot;High&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [151] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [161] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [171] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [181] &quot;Low&quot; &quot;High&quot; &quot;High&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;High&quot; &quot;High&quot; ## [191] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;High&quot; &quot;High&quot; &quot;High&quot; &quot;High&quot; &quot;Low&quot; &quot;Low&quot; ## [201] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [211] &quot;Low&quot; &quot;Low&quot; &quot;High&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [221] &quot;Low&quot; &quot;High&quot; &quot;High&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; ## [231] &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; &quot;Low&quot; 2.2 dplyr :: mutate In R, dplyr package is the most popular library for data preprocessing. Especially it provides pipe(‘%&gt;%’), and it’s very helpful for intuitive coding. And mutate in dplyr package do exactly same work as the one above, However it is simpler and easier to use. Let’s see this. (before load, you have to install “dplyr” package) # install.packages(&quot;dplyr&quot;) library(dplyr) head(df_mpg) ## # A tibble: 6 x 12 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa… ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa… ## 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa… ## 4 audi a4 2 2008 4 auto(av) f 21 30 p compa… ## 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compa… ## 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compa… ## # … with 1 more variable: eval_hwy &lt;chr&gt; We’ll use mutate function and pipe syntex to handle cty(city fuel economy) column. df_mpg %&gt;% mutate(mean_fuel = (cty + hwy)/2) %&gt;% head ## # A tibble: 6 x 13 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa… ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa… ## 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa… ## 4 audi a4 2 2008 4 auto(av) f 21 30 p compa… ## 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compa… ## 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compa… ## # … with 2 more variables: eval_hwy &lt;chr&gt;, mean_fuel &lt;dbl&gt; We can see the last column is added and named with mean_fuel. We didn’t have to use the name of dataframa(df_mpg) repeatly to use columns. It’s very nice. And of course we can use ifelse function with the pipe and mutate. df_mpg %&gt;% mutate(mean_fuel = (cty + hwy)/2, eval_fuel = ifelse(mean_fuel &gt; 20, &#39;high&#39;, &#39;low&#39;)) %&gt;% head ## # A tibble: 6 x 14 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa… ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa… ## 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa… ## 4 audi a4 2 2008 4 auto(av) f 21 30 p compa… ## 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compa… ## 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compa… ## # … with 3 more variables: eval_hwy &lt;chr&gt;, mean_fuel &lt;dbl&gt;, eval_fuel &lt;chr&gt; If you want to use this data table continuously, you have to assign this table to the new variable like this. new_mpg &lt;- df_mpg %&gt;% mutate(mean_fuel = (cty + hwy)/2, eval_fuel = ifelse(mean_fuel &gt; 20, &#39;high&#39;, &#39;low&#39;)) str(new_mpg) ## tibble [234 × 14] (S3: tbl_df/tbl/data.frame) ## $ manufacturer: chr [1:234] &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; ... ## $ model : chr [1:234] &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; ... ## $ displ : num [1:234] 1.8 1.8 2 2 2.8 2.8 3.1 1.8 1.8 2 ... ## $ year : int [1:234] 1999 1999 2008 2008 1999 1999 2008 1999 1999 2008 ... ## $ cyl : int [1:234] 4 4 4 4 6 6 6 4 4 4 ... ## $ trans : chr [1:234] &quot;auto(l5)&quot; &quot;manual(m5)&quot; &quot;manual(m6)&quot; &quot;auto(av)&quot; ... ## $ drv : chr [1:234] &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; ... ## $ cty : int [1:234] 18 21 20 21 16 18 18 18 16 20 ... ## $ hwy : int [1:234] 29 29 31 30 26 26 27 26 25 28 ... ## $ fl : chr [1:234] &quot;p&quot; &quot;p&quot; &quot;p&quot; &quot;p&quot; ... ## $ class : chr [1:234] &quot;compact&quot; &quot;compact&quot; &quot;compact&quot; &quot;compact&quot; ... ## $ eval_hwy : chr [1:234] &quot;Low&quot; &quot;Low&quot; &quot;High&quot; &quot;Low&quot; ... ## $ mean_fuel : num [1:234] 23.5 25 25.5 25.5 21 22 22.5 22 20.5 24 ... ## $ eval_fuel : chr [1:234] &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; ... qplot(new_mpg$mean_fuel) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. qplot(new_mpg$eval_fuel) We can use more functions from dplyr package. The commonly used functions that except mutate we have seen already are filter(), select(), arrange(), summarise(). Let’s look at these one by one. 2.3 dplyr :: filter First, filter() function. filter extracts rows by some conditions. head(new_mpg) ## # A tibble: 6 x 14 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa… ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa… ## 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa… ## 4 audi a4 2 2008 4 auto(av) f 21 30 p compa… ## 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compa… ## 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compa… ## # … with 3 more variables: eval_hwy &lt;chr&gt;, mean_fuel &lt;dbl&gt;, eval_fuel &lt;chr&gt; If you want to extract only audi, you can use filter. new_mpg %&gt;% filter(manufacturer==&#39;audi&#39;) ## # A tibble: 18 x 14 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l… f 18 29 p comp… ## 2 audi a4 1.8 1999 4 manual… f 21 29 p comp… ## 3 audi a4 2 2008 4 manual… f 20 31 p comp… ## 4 audi a4 2 2008 4 auto(a… f 21 30 p comp… ## 5 audi a4 2.8 1999 6 auto(l… f 16 26 p comp… ## 6 audi a4 2.8 1999 6 manual… f 18 26 p comp… ## 7 audi a4 3.1 2008 6 auto(a… f 18 27 p comp… ## 8 audi a4 quat… 1.8 1999 4 manual… 4 18 26 p comp… ## 9 audi a4 quat… 1.8 1999 4 auto(l… 4 16 25 p comp… ## 10 audi a4 quat… 2 2008 4 manual… 4 20 28 p comp… ## 11 audi a4 quat… 2 2008 4 auto(s… 4 19 27 p comp… ## 12 audi a4 quat… 2.8 1999 6 auto(l… 4 15 25 p comp… ## 13 audi a4 quat… 2.8 1999 6 manual… 4 17 25 p comp… ## 14 audi a4 quat… 3.1 2008 6 auto(s… 4 17 25 p comp… ## 15 audi a4 quat… 3.1 2008 6 manual… 4 15 25 p comp… ## 16 audi a6 quat… 2.8 1999 6 auto(l… 4 15 24 p mids… ## 17 audi a6 quat… 3.1 2008 6 auto(s… 4 17 25 p mids… ## 18 audi a6 quat… 4.2 2008 8 auto(s… 4 16 23 p mids… ## # … with 3 more variables: eval_hwy &lt;chr&gt;, mean_fuel &lt;dbl&gt;, eval_fuel &lt;chr&gt; If you want to extract audi a4 model, new_mpg %&gt;% filter(manufacturer==&#39;audi&#39; &amp; model==&#39;a4&#39;) ## # A tibble: 7 x 14 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa… ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa… ## 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa… ## 4 audi a4 2 2008 4 auto(av) f 21 30 p compa… ## 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compa… ## 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compa… ## 7 audi a4 3.1 2008 6 auto(av) f 18 27 p compa… ## # … with 3 more variables: eval_hwy &lt;chr&gt;, mean_fuel &lt;dbl&gt;, eval_fuel &lt;chr&gt; If you want to extract audi a4 that have Good for highway fuel economy, new_mpg %&gt;% filter(manufacturer==&#39;audi&#39; &amp; model==&#39;a4&#39; &amp; eval_hwy == &#39;High&#39;) ## # A tibble: 1 x 14 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 2 2008 4 manual(m6) f 20 31 p compa… ## # … with 3 more variables: eval_hwy &lt;chr&gt;, mean_fuel &lt;dbl&gt;, eval_fuel &lt;chr&gt; Yes, now you can choose the car that you want. 2.4 dplyr :: select Next, select() function. We have used filter() to extract rows, now we’ll use select() to extract columns. new_mpg %&gt;% select(manufacturer) %&gt;% head ## # A tibble: 6 x 1 ## manufacturer ## &lt;chr&gt; ## 1 audi ## 2 audi ## 3 audi ## 4 audi ## 5 audi ## 6 audi Two or more columns can be extracted at the same time. new_mpg %&gt;% select(manufacturer, class, hwy) %&gt;% head ## # A tibble: 6 x 3 ## manufacturer class hwy ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 audi compact 29 ## 2 audi compact 29 ## 3 audi compact 31 ## 4 audi compact 30 ## 5 audi compact 26 ## 6 audi compact 26 And with pipe, we can extract some rows and some columns at the same time too. new_mpg %&gt;% select(manufacturer, model, class, hwy) %&gt;% filter(hwy &gt; 23) %&gt;% head(10) ## # A tibble: 10 x 4 ## manufacturer model class hwy ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 audi a4 compact 29 ## 2 audi a4 compact 29 ## 3 audi a4 compact 31 ## 4 audi a4 compact 30 ## 5 audi a4 compact 26 ## 6 audi a4 compact 26 ## 7 audi a4 compact 27 ## 8 audi a4 quattro compact 26 ## 9 audi a4 quattro compact 25 ## 10 audi a4 quattro compact 28 2.5 dplyr :: arrange In case of numerical data(variable), we can order it. If data is categorical variable, It’ll return error. new_mpg %&gt;% select(manufacturer, model, class, hwy) %&gt;% arrange(hwy) %&gt;% head(10) ## # A tibble: 10 x 4 ## manufacturer model class hwy ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 dodge dakota pickup 4wd pickup 12 ## 2 dodge durango 4wd suv 12 ## 3 dodge ram 1500 pickup 4wd pickup 12 ## 4 dodge ram 1500 pickup 4wd pickup 12 ## 5 jeep grand cherokee 4wd suv 12 ## 6 chevrolet k1500 tahoe 4wd suv 14 ## 7 jeep grand cherokee 4wd suv 14 ## 8 chevrolet c1500 suburban 2wd suv 15 ## 9 chevrolet k1500 tahoe 4wd suv 15 ## 10 dodge dakota pickup 4wd pickup 15 If you want to sort dataset from highest to lowest highway fuel economy, wrapping arrange variable by desc() new_mpg %&gt;% select(manufacturer, model, class, hwy) %&gt;% arrange(desc(hwy)) %&gt;% head(10) ## # A tibble: 10 x 4 ## manufacturer model class hwy ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 volkswagen jetta compact 44 ## 2 volkswagen new beetle subcompact 44 ## 3 volkswagen new beetle subcompact 41 ## 4 toyota corolla compact 37 ## 5 honda civic subcompact 36 ## 6 honda civic subcompact 36 ## 7 toyota corolla compact 35 ## 8 toyota corolla compact 35 ## 9 honda civic subcompact 34 ## 10 honda civic subcompact 33 2.6 dplyr :: summarise The function summarise() can be used to get basic statistics by specifying functions such as mean(), sd(), median(), etc. new_mpg %&gt;% filter(manufacturer==&#39;audi&#39;) %&gt;% summarise(mean_hwy = mean(hwy)) ## # A tibble: 1 x 1 ## mean_hwy ## &lt;dbl&gt; ## 1 26.4 head(10) ## [1] 10 new_mpg %&gt;% filter(manufacturer==&#39;audi&#39;) %&gt;% summarise(mean_hwy = mean(hwy), max_hwy = max(hwy), min_hwy = min(hwy)) ## # A tibble: 1 x 3 ## mean_hwy max_hwy min_hwy ## &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 26.4 31 23 head(10) ## [1] 10 But, this function can be more useful if used together with groupby. new_mpg %&gt;% group_by(manufacturer) %&gt;% summarise(mean_hwy = mean(hwy), max_hwy = max(hwy), min_hwy = min(hwy)) ## # A tibble: 15 x 4 ## manufacturer mean_hwy max_hwy min_hwy ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 audi 26.4 31 23 ## 2 chevrolet 21.9 30 14 ## 3 dodge 17.9 24 12 ## 4 ford 19.4 26 15 ## 5 honda 32.6 36 29 ## 6 hyundai 26.9 31 24 ## 7 jeep 17.6 22 12 ## 8 land rover 16.5 18 15 ## 9 lincoln 17 18 16 ## 10 mercury 18 19 17 ## 11 nissan 24.6 32 17 ## 12 pontiac 26.4 28 25 ## 13 subaru 25.6 27 23 ## 14 toyota 24.9 37 15 ## 15 volkswagen 29.2 44 23 we can apply arrange() too. new_mpg %&gt;% group_by(manufacturer) %&gt;% summarise(mean_hwy = mean(hwy), max_hwy = max(hwy), min_hwy = min(hwy)) %&gt;% arrange(desc(mean_hwy)) ## # A tibble: 15 x 4 ## manufacturer mean_hwy max_hwy min_hwy ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 honda 32.6 36 29 ## 2 volkswagen 29.2 44 23 ## 3 hyundai 26.9 31 24 ## 4 audi 26.4 31 23 ## 5 pontiac 26.4 28 25 ## 6 subaru 25.6 27 23 ## 7 toyota 24.9 37 15 ## 8 nissan 24.6 32 17 ## 9 chevrolet 21.9 30 14 ## 10 ford 19.4 26 15 ## 11 mercury 18 19 17 ## 12 dodge 17.9 24 12 ## 13 jeep 17.6 22 12 ## 14 lincoln 17 18 16 ## 15 land rover 16.5 18 15 We select 2 or more columns to group_by function like this. new_mpg %&gt;% group_by(manufacturer, model) %&gt;% summarise(mean_hwy = mean(hwy), max_hwy = max(hwy), min_hwy = min(hwy)) ## `summarise()` has grouped output by &#39;manufacturer&#39;. You can override using the `.groups` argument. ## # A tibble: 38 x 5 ## # Groups: manufacturer [15] ## manufacturer model mean_hwy max_hwy min_hwy ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 audi a4 28.3 31 26 ## 2 audi a4 quattro 25.8 28 25 ## 3 audi a6 quattro 24 25 23 ## 4 chevrolet c1500 suburban 2wd 17.8 20 15 ## 5 chevrolet corvette 24.8 26 23 ## 6 chevrolet k1500 tahoe 4wd 16.2 19 14 ## 7 chevrolet malibu 27.6 30 26 ## 8 dodge caravan 2wd 22.4 24 17 ## 9 dodge dakota pickup 4wd 17 19 12 ## 10 dodge durango 4wd 16 18 12 ## # … with 28 more rows and apply filter() too. new_mpg %&gt;% group_by(manufacturer, model) %&gt;% summarise(mean_hwy = mean(hwy), max_hwy = max(hwy), min_hwy = min(hwy)) %&gt;% filter(manufacturer==&#39;audi&#39; | manufacturer==&#39;hyundai&#39;) ## `summarise()` has grouped output by &#39;manufacturer&#39;. You can override using the `.groups` argument. ## # A tibble: 5 x 5 ## # Groups: manufacturer [2] ## manufacturer model mean_hwy max_hwy min_hwy ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 audi a4 28.3 31 26 ## 2 audi a4 quattro 25.8 28 25 ## 3 audi a6 quattro 24 25 23 ## 4 hyundai sonata 27.7 31 26 ## 5 hyundai tiburon 26 29 24 2.7 dplyr :: left_join dplyr package contain join functions. First, we try left_join() for our custom data. students &lt;- c(&#39;Jennie&#39;, &#39;Tom&#39;, &#39;Minsu&#39;, &#39;Jay&#39;, &#39;Bob&#39;) classes &lt;- c(&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;) keys &lt;- c(&#39;JN&#39;, &#39;T&#39;, &#39;M&#39;, &#39;J&#39;, &#39;B&#39;) heights &lt;- c(155, 190, 165, 177, 180) weights &lt;- c(57, 101, 64, 80, 88) class_info &lt;- data.frame(students, classes) students_info &lt;- data.frame(students, keys, heights, weights) head(class_info) ## students classes ## 1 Jennie A ## 2 Tom B ## 3 Minsu C ## 4 Jay D ## 5 Bob E head(students_info) ## students keys heights weights ## 1 Jennie JN 155 57 ## 2 Tom T 190 101 ## 3 Minsu M 165 64 ## 4 Jay J 177 80 ## 5 Bob B 180 88 If we have to combine this two table, We need some “point”s. This means some “column”s that two table have in common. In this example, students column is that. Let’s combine datasets by Setting students column as a point. all_info &lt;- left_join(class_info, students_info, by=&#39;students&#39;) all_info ## students classes keys heights weights ## 1 Jennie A JN 155 57 ## 2 Tom B T 190 101 ## 3 Minsu C M 165 64 ## 4 Jay D J 177 80 ## 5 Bob E B 180 88 2.8 dplyr :: right_join What if we use right_join()? In this table, it’s same. all_info2 &lt;- right_join(class_info, students_info, by=&#39;students&#39;) all_info2 ## students classes keys heights weights ## 1 Jennie A JN 155 57 ## 2 Tom B T 190 101 ## 3 Minsu C M 165 64 ## 4 Jay D J 177 80 ## 5 Bob E B 180 88 Because left table(class_info) and right rable(students_info) have same variable(students). If one side has Na in students column, the result will be different. students_info2 &lt;- students_info[-1,] students_info2 ## students keys heights weights ## 2 Tom T 190 101 ## 3 Minsu M 165 64 ## 4 Jay J 177 80 ## 5 Bob B 180 88 all_info3 &lt;- left_join(class_info, students_info2, by=&#39;students&#39;) all_info3 ## students classes keys heights weights ## 1 Jennie A &lt;NA&gt; NA NA ## 2 Tom B T 190 101 ## 3 Minsu C M 165 64 ## 4 Jay D J 177 80 ## 5 Bob E B 180 88 let’s see this. We have founded 3 NA values. It’s bacause students_info2 didn’t have the Jennie’s informatino(row) But, all_info4 &lt;- right_join(class_info, students_info2, by=&#39;students&#39;) all_info4 ## students classes keys heights weights ## 1 Tom B T 190 101 ## 2 Minsu C M 165 64 ## 3 Jay D J 177 80 ## 4 Bob E B 180 88 If we have chosen right_join() at this moment, we can get different result like this. It’s because students_info2 didn’t have the Jennie’s informatino(row). Same. right_join() receives two inputs like left_join(), and joins tables based on the right (second) input. 2.9 dplyr :: inner_join How can we join tables if we met all of tables are have NA at base column of reference? Like this case, class_info2 &lt;- class_info[-2,] class_info2 ## students classes ## 1 Jennie A ## 3 Minsu C ## 4 Jay D ## 5 Bob E all_info4 &lt;- left_join(class_info2, students_info2, by=&#39;students&#39;) all_info4 ## students classes keys heights weights ## 1 Jennie A &lt;NA&gt; NA NA ## 2 Minsu C M 165 64 ## 3 Jay D J 177 80 ## 4 Bob E B 180 88 all_info5 &lt;- right_join(class_info2, students_info2, by=&#39;students&#39;) all_info5 ## students classes keys heights weights ## 1 Minsu C M 165 64 ## 2 Jay D J 177 80 ## 3 Bob E B 180 88 ## 4 Tom &lt;NA&gt; T 190 101 Yes, returns have NA all as expected. But we want to get result that without missing value. In this case, we can use inner_join() all_info6 &lt;- inner_join(class_info2, students_info2, by=&#39;students&#39;) all_info6 ## students classes keys heights weights ## 1 Minsu C M 165 64 ## 2 Jay D J 177 80 ## 3 Bob E B 180 88 2.10 dplyr :: full_join Conversely, if we want to display all values together even if there are missing values in left or right, we can use full_join() all_info7 &lt;- full_join(class_info2, students_info2, by=&#39;students&#39;) all_info7 ## students classes keys heights weights ## 1 Jennie A &lt;NA&gt; NA NA ## 2 Minsu C M 165 64 ## 3 Jay D J 177 80 ## 4 Bob E B 180 88 ## 5 Tom &lt;NA&gt; T 190 101 2.11 dplyr :: bind_cols If two data tables have the same number of rows, you can use bind_cols(). It is simple and return different result from join. bind_cols(class_info2, students_info2) ## New names: ## * students -&gt; students...1 ## * students -&gt; students...3 ## students...1 classes students...3 keys heights weights ## 1 Jennie A Tom T 190 101 ## 2 Minsu C Minsu M 165 64 ## 3 Jay D Jay J 177 80 ## 4 Bob E Bob B 180 88 Yes, it just concatenate two tables. There is no reference column. So, same number of rows should be noted. If each number of rows are different, It returns error. class_info ## students classes ## 1 Jennie A ## 2 Tom B ## 3 Minsu C ## 4 Jay D ## 5 Bob E students_info2 ## students keys heights weights ## 2 Tom T 190 101 ## 3 Minsu M 165 64 ## 4 Jay J 177 80 ## 5 Bob B 180 88 bind_cols(class_info, students_info2) ## Error: Can&#39;t recycle `..1` (size 5) to match `..2` (size 4). Run `rlang::last_error()` to see where the error occurred. 2.12 dplyr :: bind_rows Unlike bind_cols(), it can join tables with different columns. fruit &lt;- c(&#39;apple&#39;, &#39;banana&#39;, &#39;watermelon&#39;, &#39;mango&#39;) berry &lt;- c(&#39;strawberry&#39;, &#39;raspberry&#39;, &#39;mulberry&#39;, &#39;wildberry&#39;) print(fruit) ## [1] &quot;apple&quot; &quot;banana&quot; &quot;watermelon&quot; &quot;mango&quot; print(berry) ## [1] &quot;strawberry&quot; &quot;raspberry&quot; &quot;mulberry&quot; &quot;wildberry&quot; fruit_df &lt;- data.frame(fruit) fruit_df ## fruit ## 1 apple ## 2 banana ## 3 watermelon ## 4 mango berry_df &lt;- data.frame(berry) berry_df ## berry ## 1 strawberry ## 2 raspberry ## 3 mulberry ## 4 wildberry fruit_df$sugar &lt;- c(3,8,2,9) berry_df$sugar &lt;- c(2,1,1,1) berry_df$color &lt;- c(&#39;red&#39;, &#39;red&#39;, &#39;black&#39;, &#39;red&#39;) print(fruit_df) ## fruit sugar ## 1 apple 3 ## 2 banana 8 ## 3 watermelon 2 ## 4 mango 9 print(berry_df) ## berry sugar color ## 1 strawberry 2 red ## 2 raspberry 1 red ## 3 mulberry 1 black ## 4 wildberry 1 red berry_df &lt;- rename(berry_df, fruit = berry) print(berry_df) ## fruit sugar color ## 1 strawberry 2 red ## 2 raspberry 1 red ## 3 mulberry 1 black ## 4 wildberry 1 red bind_rows(fruit_df, berry_df) ## fruit sugar color ## 1 apple 3 &lt;NA&gt; ## 2 banana 8 &lt;NA&gt; ## 3 watermelon 2 &lt;NA&gt; ## 4 mango 9 &lt;NA&gt; ## 5 strawberry 2 red ## 6 raspberry 1 red ## 7 mulberry 1 black ## 8 wildberry 1 red Yes, It returns data table without error even if the structure of column is different. And of course, the number of rows doesn’t matter, since we’re joining rows. But let’s check them too. bind_rows(fruit_df, berry_df[-1,]) ## fruit sugar color ## 1 apple 3 &lt;NA&gt; ## 2 banana 8 &lt;NA&gt; ## 3 watermelon 2 &lt;NA&gt; ## 4 mango 9 &lt;NA&gt; ## 5 raspberry 1 red ## 6 mulberry 1 black ## 7 wildberry 1 red Okay, Just one row decreased. "],["references.html", "References", " References "]]
