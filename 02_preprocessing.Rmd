# Data Preprocessing

While exploring data, we need to preprocess it properly for our purpose.
And these work can be repeat until we construct a dataset that can make our probabilistic model well.

## ifelse

`ifelse` is `Conditional Statments function` that is very simple and useful in R. We can use this with just 3 parameters - condition, return value when it's true, return value when it's false.

let's see example code.

first, print the head of dataset
```{r}
head(mpg$hwy)
```

And let's apply ifelse to this head.
if the hwy(highway fuel efficiency) is higher than 30, returns 'Good'.
```{r}
ifelse(head(mpg$hwy) > 30, 'Good', 'Bad')
```

We can use this data by assign method(`<-`). Let's Control Entire variable.

```{r}
evaluate_hwy <- ifelse(mpg$hwy > 30, 'Good', 'Bad')
print(evaluate_hwy)
```

Then, Why is this necessary?

Sometimes we need categorical data(nominal data or ordinal data) for not only visualization but also data handling. Especially, We do not always get gaussian distribution dataset, so since the data is not uniform, it is necessary to divide it into appropriate intervals.

We can use this function to not only create new variable but also add another column.
```{r}
df_mpg <- mpg
df_mpg['eval_hwy'] <- ifelse(df_mpg$hwy>30, 'High', 'Low')
df_mpg$eval_hwy
```

## dplyr :: mutate

In R, `dplyr` package is the most popular library for data preprocessing. Especially it provides pipe('%>%'), and it's very helpful for intuitive coding. And `mutate` in `dplyr` package do exactly same work as the one above, However it is simpler and easier to use. Let's see this.

(before load, you have to install "dplyr" package)
```{r}
# install.packages("dplyr") 
library(dplyr)
```

```{r}
head(df_mpg)
```
We'll use `mutate` function and `pipe` syntex to handle `cty`(city fuel economy) column.

```{r}
df_mpg %>%
  mutate(mean_fuel = (cty + hwy)/2) %>%
  head
```

We can see the last column is added and named with `mean_fuel`. We didn't have to use the name of dataframa(df_mpg) repeatly to use columns. It's very nice.

And of course we can use `ifelse` function with the `pipe` and `mutate`.

```{r}
df_mpg %>%
  mutate(mean_fuel = (cty + hwy)/2, 
         eval_fuel = ifelse(mean_fuel > 20, 'high', 'low')) %>%
  head
```

If you want to use this data table continuously, you have to assign this table to the new variable like this.

```{r}
new_mpg <- df_mpg %>%
            mutate(mean_fuel = (cty + hwy)/2, 
            eval_fuel = ifelse(mean_fuel > 20, 'high', 'low'))
```

```{r}
str(new_mpg)
```

```{r}
qplot(new_mpg$mean_fuel)
```

```{r}
qplot(new_mpg$eval_fuel)
```

We can use more functions from `dplyr` package. The commonly used functions that except mutate we have seen already are `filter()`, `select()`, `arrange()`, `summarise()`. Let's look at these one by one.

## dplyr :: filter

First, `filter()` function. `filter` extracts rows by some conditions. 
```{r}
head(new_mpg)
```
If you want to extract only `audi`, you can use `filter`.

```{r}
new_mpg %>%
  filter(manufacturer=='audi')
```

If you want to extract `audi a4` model, 
```{r}
new_mpg %>%
  filter(manufacturer=='audi' & model=='a4')
```

If you want to extract `audi a4` that have `Good for highway fuel economy`,
```{r}
new_mpg %>%
  filter(manufacturer=='audi' & model=='a4' & eval_hwy == 'High')
```
Yes, now you can choose the car that you want.

## dplyr :: select

Next, `select()` function. 
We have used `filter()` to extract rows, now we'll use `select()` to extract columns.

```{r}
new_mpg %>%
  select(manufacturer) %>%
  head
```

Two or more columns can be extracted at the same time.

```{r}
new_mpg %>%
  select(manufacturer, class, hwy) %>%
  head
```


And with pipe, we can extract some rows and some columns at the same time too.

```{r}
new_mpg %>%
  select(manufacturer, model, class, hwy) %>%
  filter(hwy > 23) %>%
  head(10)
```

## dplyr :: arrange

In case of numerical data(variable), we can order it. If data is categorical variable, It'll return error.

```{r}
new_mpg %>%
  select(manufacturer, model, class, hwy) %>%
  arrange(hwy) %>%
  head(10)
```

If you want to sort dataset from highest to lowest highway fuel economy, wrapping arrange variable by `desc()`

```{r}
new_mpg %>%
  select(manufacturer, model, class, hwy) %>%
  arrange(desc(hwy)) %>%
  head(10)
```

## dplyr :: summarise

The function `summarise()` can be used to get basic statistics by specifying functions such as mean(), sd(), median(), etc.

```{r}
new_mpg %>%
  filter(manufacturer=='audi') %>%
  summarise(mean_hwy = mean(hwy))
  head(10)
```

```{r}
new_mpg %>%
  filter(manufacturer=='audi') %>%
  summarise(mean_hwy = mean(hwy),
            max_hwy = max(hwy),
            min_hwy = min(hwy))
  head(10)
```
But, this function can be more useful if used together with groupby.

```{r}
new_mpg %>%
  group_by(manufacturer) %>%
  summarise(mean_hwy = mean(hwy),
            max_hwy = max(hwy),
            min_hwy = min(hwy))
```

we can apply `arrange()` too.
```{r}
new_mpg %>%
  group_by(manufacturer) %>%
  summarise(mean_hwy = mean(hwy),
            max_hwy = max(hwy),
            min_hwy = min(hwy)) %>%
  arrange(desc(mean_hwy))
```

We select 2 or more columns to `group_by` function like this.

```{r}
new_mpg %>%
  group_by(manufacturer, model) %>%
  summarise(mean_hwy = mean(hwy),
            max_hwy = max(hwy),
            min_hwy = min(hwy))
```

and apply `filter()` too.

```{r}
new_mpg %>%
  group_by(manufacturer, model) %>%
  summarise(mean_hwy = mean(hwy),
            max_hwy = max(hwy),
            min_hwy = min(hwy)) %>%
  filter(manufacturer=='audi' | manufacturer=='hyundai')
```


## dplyr :: left_join

`dplyr` package contain `join` functions. First, we try `left_join()` for our custom data.


```{r}
students <- c('Jennie', 'Tom', 'Minsu', 'Jay', 'Bob')
classes <- c('A','B','C','D','E')
keys <- c('JN', 'T', 'M', 'J', 'B')
heights <- c(155, 190, 165, 177, 180)
weights <- c(57, 101, 64, 80, 88)

class_info <- data.frame(students, classes)
students_info <- data.frame(students, keys, heights, weights)

head(class_info)
head(students_info)
```

If we have to combine this two table, We need some "point"s. This means some "column"s that two table have in common. In this example, `students` column is that.

Let's combine datasets by Setting `students` column as a point.
```{r}
all_info <- left_join(class_info, students_info, by='students')
all_info
```


## dplyr :: right_join

What if we use `right_join()`?
In this table, it's same.

```{r}
all_info2 <- right_join(class_info, students_info, by='students')
all_info2
```

Because left table(class_info) and right rable(students_info) have same variable(students).

If one side has Na in `students` column, the result will be different.

```{r}
students_info2 <- students_info[-1,]
students_info2
```

```{r}
all_info3 <- left_join(class_info, students_info2, by='students')
all_info3
```

let's see this. We have founded 3 NA values. It's bacause students_info2 didn't have the Jennie's informatino(row)
But,
```{r}
all_info4 <- right_join(class_info, students_info2, by='students')
all_info4
```

If we have chosen `right_join()` at this moment, we can get different result like this.
It's because students_info2 didn't have the Jennie's informatino(row). Same.

`right_join()` receives two inputs like `left_join()`, and joins tables based on the right (second) input.


## dplyr :: inner_join

How can we join tables if we met all of tables are have `NA` at base column of reference?
Like this case,
```{r}
class_info2 <- class_info[-2,]
class_info2
```

```{r}
all_info4 <- left_join(class_info2, students_info2, by='students')
all_info4
```

```{r}
all_info5 <- right_join(class_info2, students_info2, by='students')
all_info5
```

Yes, returns have `NA` all as expected.
But we want to get result that without missing value. In this case, we can use `inner_join()`
```{r}
all_info6 <- inner_join(class_info2, students_info2, by='students')
all_info6
```


## dplyr :: full_join

Conversely, if we want to display all values together even if there are missing values in left or right, we can use `full_join()`

```{r}
all_info7 <- full_join(class_info2, students_info2, by='students')
all_info7
```



