# R Basic

Let's check the types and data structures in R. At the same time, let's prepare to deal with R by taking a look at the built-in functions that R has by default.

## Data Types

R has 6 basic data types. 
- character
- numeric
- integer
- logical
- complex
- raw

And we can deal with these data types by using basic functions.
```{r}
character(3) # show the collection of 3 character elements
typeof('Hello') # show the type of 'Hello'(character)
length('Hello') # show the length of 'Hello'(1 character)
str('Hello') # show the structure of 'Hello'
```

There are 3 ways to represent numbers

```{r}
numeric(3) 
integer(3)
complex(3)

typeof(numeric(3))
typeof(integer(3))
typeof(complex(3))

str(numeric(3))
str(integer(3))
str(complex(3))
```

and logical type.

```{r}
logical(5) # show the collection of 5 logical elements
typeof(logical(5)) # show the type of the logical collection
length(logical(5)) # show the length of the logical collection, or the number of the logical elements(5)
str(logical(5)) # show the structure of the logical collection
```

The `raw` can represent a hex digit. So if we want to get ASCII code, we can use this. Contrary, we can convert ASCII code to ASCII characters.

```{r}
raw(5)
typeof(raw(5))
length(raw(5)) 

ctr <- charToRaw('hi this is ASCII')
print(ctr)
rawToChar(ctr)
```


## Data Structure 

Data structure is container that contain data elements. There are 5 basic data structures in R.
- vector
- matrix
- dataframe
- array
- list

## Data Structure - vector

A vector is a data structure composed of one or more elements, and all elements must have the same data type.

In fact, we made and output a vector while checking each type earlier.

```{r}
sample <- 'A'
sample2 <- c(1,2)
sample3 <- c(1,2,'A')

str(sample)
str(sample2)
str(sample3)
```

All of that are vectors. The peculiar thing is that sample3 is of type chr. Repeat, all elements must have the same data type in vector.

We see here that classes are not represented as vectors in vector structures. In R, a vector is the smallest data structure unit, so the class of the vector is data type as it is.

## Data Structure - matrix

Matrix is 2 dimension data structure and it requires all elements in this structure to be of the same data type.

```{r}
vector1 <- c(1,2,3,4,5,6,7,8,9,10)
```


1. Create a metric by filling the column first :

```{r}
matrix(vector1, nrow=2, ncol=5)
```

2. Create a metric by filling the row first :

```{r}
matrix(vector1, nrow=2, ncol=5, byrow=T)
```

3. Check the type of data(metrix) :

```{r}
mtr <- matrix(vector1, nrow=2, ncol=5, byrow=T)
class(mtr)
```


Unlike vectors, matrix represent classes well as "matrix".

If, you want to combine multiple vectors, you can use `cbind` or `rbind`.

```{r}
vector2 <- c(10,20,30,40,50,60,70,80,90,100)

cbind(vector1, vector2)
```

If cbind combines vectors on a column basis, rbind can combine on a row basis.

```{r}
rbind(vector1[1:5], vector2[1:5])
```

We used indexing here. Only a specific section of a vector can be extracted through '[a,b]'.

Let's take a quick look at indexing.

```{r}
vector2[c(1,3,5,7)]
```

```{r}
vector2[seq(1,8,2)]
```

```{r}
vector2[-1]
```

In this way, you can extract a value with a specific index through `c()`, set the interval and search interval with `seq()`, or exclude only the value of a specific index.(-)

Next, Matrix indexing.

```{r}
mtr
```

1. row - 1, column - 1~3 : 
```{r}
mtr[1,1:3]
```

2. row - all, column - 4~5 :
```{r}
mtr[,4:5]
```

3. row - 2, column - all :
```{r}
mtr[2,]
```

4. row - all, column - 1,3,5 :
```{r}
mtr[,c(1,3,5)]
```

5. row - all, column - extract 1 and all :
```{r}
mtr[,-1]
```

Indexing is very important. Handling vectors and matrices freely is a key skill that must be preceded by data preprocessing.

## Data Structure - dataframe

Dataframe is 2 dimension data structure that it's datatypes do not need to be uniform. That is, unlike a matrix, various types of vectors can be combined.

```{r}
column1 <- c(1,2,3,4,5)
column2 <- c(10,20,30,40,50)
column3 <- c('hi', 'this', 'is', 'vector', '!')

sample_df <- data.frame(column1, column2, column3)

str(sample_df)
class(sample_df)
```

The indexing used for metrics can be applied to data frames as well.

```{r}
sample_df
```

1. row - 1, column - all :
```{r}
sample_df[1, ]
```
2. row - all, column - 1~2 :
```{r}
sample_df[,1:2]
```

3. row - all, column - extract 1 and all :

```{r}
sample_df[,-1]
```

## Data Structure - array

An array is a multi-dimensional data structure that can express two or more dimensions of a matrix, and all elements must be of the same data type, just like a matrix.

1. 1 dimension :
```{r}
array(1:10)
```

2. 2 dimension :
```{r}
array(1:10, dim=c(5,2)) # c(row, column)
```

3. 3 dimension :
```{r}
array(1:30, dim=c(5,2,3)) # c(row, column, N)
```

4. 4 dimension :
```{r}
array(1:200, dim=c(5, 10, 2, 2)) # c(row, column, N, N)
```

We can use indexing for array too. But it could be more complex than matrix or vector.

```{r}
test <- array(1:200, dim=c(5, 10, 2, 2))
```

```{r}
test[3:5,,,] # row indexing
```

```{r}
test[3:5,5:8,,] # row and column indexing
```

```{r}
test[3:5,5:8,2,2] # row and column + N(2,2) indexing ==> extract part(some rows and some columns) of last matrix in array
```

## Data Structure - list

List is the most flexible data structure in R. It can be expressed in all dimensions and can be expressed by collecting various data types.

```{r}
li <- list(c(1,2,3,4), c('hi','im','in','list'), sample_df)
li
```

We can find double square brackets for each indexes. So if we want to extract some values(not vector) from list, we have to use double bracket('[[', ']]').

First, If we need to 1 vector in list, the indexing method above can be used. 
for example,
```{r}
sample_df[1] # extract 1 column(vector)
```


```{r}
li[1]
```

Here comes the other part, if you want to go deeper, i.e. extract only a few elements in smaller units, you have to use double brackets. 
Like this,

```{r}
li[[1]][1:3]
```

What makes difference?

In list, if we use one bracket, it returns list type.

```{r}
li[2]
```
```{r}
typeof(li[2])
```

and if we use double brackets, it returns the collection's data type.

```{r}
typeof(li[[2]])
```

That is why you need to use double brackets to access a specific value of a list in a list

```{r}
li[[2]][2:4]
```

```{r}
li[[3]][2:1,2:3] # indexing : first list, second dataframe
```
In the list, you can name the internal list just like the columns of the data frame.

```{r}
li2 <- list(nu=c(1,2,3,4,5),
            ch=c('hi','hello','hey'),
            df=data.frame(c('a','b','c'),c('any','baby','can'),c(10,11,12)))
str(li2)
```

And if you've name each lists, you can call them using '$'.

```{r}
li2$nu
```

```{r}
li2$ch
```

```{r}
li2$df
```

As you may have noticed, it does the same thing as double brackets.

```{r}
str(li2[[3]])
```

```{r}
str(li2$df)
```

Finally, let's look at the difference between using only one bracket.

```{r}
str(li2[3])
```
